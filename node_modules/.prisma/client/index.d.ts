
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Parish
 * 
 */
export type Parish = $Result.DefaultSelection<Prisma.$ParishPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Rate
 * 
 */
export type Rate = $Result.DefaultSelection<Prisma.$RatePayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.parish`: Exposes CRUD operations for the **Parish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parishes
    * const parishes = await prisma.parish.findMany()
    * ```
    */
  get parish(): Prisma.ParishDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.rate`: Exposes CRUD operations for the **Rate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rates
    * const rates = await prisma.rate.findMany()
    * ```
    */
  get rate(): Prisma.RateDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Region: 'Region',
    Location: 'Location',
    Parish: 'Parish',
    Material: 'Material',
    Unit: 'Unit',
    Rate: 'Rate',
    Supplier: 'Supplier',
    Product: 'Product'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'region' | 'location' | 'parish' | 'material' | 'unit' | 'rate' | 'supplier' | 'product'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>,
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Parish: {
        payload: Prisma.$ParishPayload<ExtArgs>
        fields: Prisma.ParishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParishFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParishFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          findFirst: {
            args: Prisma.ParishFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParishFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          findMany: {
            args: Prisma.ParishFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>[]
          }
          create: {
            args: Prisma.ParishCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          createMany: {
            args: Prisma.ParishCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParishDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          update: {
            args: Prisma.ParishUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          deleteMany: {
            args: Prisma.ParishDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParishUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParishUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParishPayload>
          }
          aggregate: {
            args: Prisma.ParishAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParish>
          }
          groupBy: {
            args: Prisma.ParishGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParishGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParishCountArgs<ExtArgs>,
            result: $Utils.Optional<ParishCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>,
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>,
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Rate: {
        payload: Prisma.$RatePayload<ExtArgs>
        fields: Prisma.RateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          findFirst: {
            args: Prisma.RateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          findMany: {
            args: Prisma.RateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>[]
          }
          create: {
            args: Prisma.RateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          createMany: {
            args: Prisma.RateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          update: {
            args: Prisma.RateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          deleteMany: {
            args: Prisma.RateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatePayload>
          }
          aggregate: {
            args: Prisma.RateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRate>
          }
          groupBy: {
            args: Prisma.RateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateCountArgs<ExtArgs>,
            result: $Utils.Optional<RateCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    locations: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | RegionCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }



  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    parishes: number
    User: number
    Product: number
    Supplier: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parishes?: boolean | LocationCountOutputTypeCountParishesArgs
    User?: boolean | LocationCountOutputTypeCountUserArgs
    Product?: boolean | LocationCountOutputTypeCountProductArgs
    Supplier?: boolean | LocationCountOutputTypeCountSupplierArgs
  }

  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountParishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParishWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }



  /**
   * Count Type ParishCountOutputType
   */

  export type ParishCountOutputType = {
    materials: number
    Rate: number
    Supplier: number
    Product: number
  }

  export type ParishCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | ParishCountOutputTypeCountMaterialsArgs
    Rate?: boolean | ParishCountOutputTypeCountRateArgs
    Supplier?: boolean | ParishCountOutputTypeCountSupplierArgs
    Product?: boolean | ParishCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParishCountOutputType
     */
    select?: ParishCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }


  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeCountRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateWhereInput
  }


  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeCountSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }


  /**
   * ParishCountOutputType without action
   */
  export type ParishCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    rates: number
    Product: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | MaterialCountOutputTypeCountRatesArgs
    Product?: boolean | MaterialCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateWhereInput
  }


  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    materials: number
    Rate: number
    Product: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | UnitCountOutputTypeCountMaterialsArgs
    Rate?: boolean | UnitCountOutputTypeCountRateArgs
    Product?: boolean | UnitCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateWhereInput
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type RateCountOutputType
   */

  export type RateCountOutputType = {
    Product: number
  }

  export type RateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | RateCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * RateCountOutputType without action
   */
  export type RateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCountOutputType
     */
    select?: RateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RateCountOutputType without action
   */
  export type RateCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    rates: number
    Product: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | SupplierCountOutputTypeCountRatesArgs
    Product?: boolean | SupplierCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateWhereInput
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    locationId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    locationId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    phone: number
    locationId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    locationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    locationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    locationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    phone: string | null
    locationId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    locationId?: boolean
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    locationId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | User$locationArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
      phone: string | null
      locationId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    location<T extends User$locationArgs<ExtArgs> = {}>(args?: Subset<T, User$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly locationId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.location
   */
  export type User$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    regionName: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    regionName: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    regionName: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    regionName?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    regionName?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    regionName?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    regionName: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionName?: boolean
    locations?: boolean | Region$locationsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    regionName?: boolean
  }

  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Region$locationsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionName: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }


  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionCreateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    locations<T extends Region$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Region$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly regionName: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }


  /**
   * Region.locations
   */
  export type Region$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
  }



  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    locationName: string | null
    regionId: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    locationName: string | null
    regionId: number | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    locationName: number
    regionId: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    locationName?: true
    regionId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    locationName?: true
    regionId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    locationName?: true
    regionId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    locationName: string
    regionId: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    regionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    parishes?: boolean | Location$parishesArgs<ExtArgs>
    User?: boolean | Location$UserArgs<ExtArgs>
    Product?: boolean | Location$ProductArgs<ExtArgs>
    Supplier?: boolean | Location$SupplierArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    locationName?: boolean
    regionId?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    parishes?: boolean | Location$parishesArgs<ExtArgs>
    User?: boolean | Location$UserArgs<ExtArgs>
    Product?: boolean | Location$ProductArgs<ExtArgs>
    Supplier?: boolean | Location$SupplierArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      parishes: Prisma.$ParishPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
      Supplier: Prisma.$SupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      locationName: string
      regionId: number
    }, ExtArgs["result"]["location"]>
    composites: {}
  }


  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends LocationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationCreateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Locations.
     *     @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends LocationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends LocationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parishes<T extends Location$parishesArgs<ExtArgs> = {}>(args?: Subset<T, Location$parishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findMany'> | Null>;

    User<T extends Location$UserArgs<ExtArgs> = {}>(args?: Subset<T, Location$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Location$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Location$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    Supplier<T extends Location$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, Location$SupplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly locationName: FieldRef<"Location", 'String'>
    readonly regionId: FieldRef<"Location", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }


  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }


  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }


  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }


  /**
   * Location.parishes
   */
  export type Location$parishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    where?: ParishWhereInput
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    cursor?: ParishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }


  /**
   * Location.User
   */
  export type Location$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Location.Product
   */
  export type Location$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Location.Supplier
   */
  export type Location$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
  }



  /**
   * Model Parish
   */

  export type AggregateParish = {
    _count: ParishCountAggregateOutputType | null
    _avg: ParishAvgAggregateOutputType | null
    _sum: ParishSumAggregateOutputType | null
    _min: ParishMinAggregateOutputType | null
    _max: ParishMaxAggregateOutputType | null
  }

  export type ParishAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type ParishSumAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type ParishMinAggregateOutputType = {
    id: number | null
    parishName: string | null
    locationId: number | null
  }

  export type ParishMaxAggregateOutputType = {
    id: number | null
    parishName: string | null
    locationId: number | null
  }

  export type ParishCountAggregateOutputType = {
    id: number
    parishName: number
    locationId: number
    _all: number
  }


  export type ParishAvgAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type ParishSumAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type ParishMinAggregateInputType = {
    id?: true
    parishName?: true
    locationId?: true
  }

  export type ParishMaxAggregateInputType = {
    id?: true
    parishName?: true
    locationId?: true
  }

  export type ParishCountAggregateInputType = {
    id?: true
    parishName?: true
    locationId?: true
    _all?: true
  }

  export type ParishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parish to aggregate.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parishes
    **/
    _count?: true | ParishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParishMaxAggregateInputType
  }

  export type GetParishAggregateType<T extends ParishAggregateArgs> = {
        [P in keyof T & keyof AggregateParish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParish[P]>
      : GetScalarType<T[P], AggregateParish[P]>
  }




  export type ParishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParishWhereInput
    orderBy?: ParishOrderByWithAggregationInput | ParishOrderByWithAggregationInput[]
    by: ParishScalarFieldEnum[] | ParishScalarFieldEnum
    having?: ParishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParishCountAggregateInputType | true
    _avg?: ParishAvgAggregateInputType
    _sum?: ParishSumAggregateInputType
    _min?: ParishMinAggregateInputType
    _max?: ParishMaxAggregateInputType
  }

  export type ParishGroupByOutputType = {
    id: number
    parishName: string
    locationId: number
    _count: ParishCountAggregateOutputType | null
    _avg: ParishAvgAggregateOutputType | null
    _sum: ParishSumAggregateOutputType | null
    _min: ParishMinAggregateOutputType | null
    _max: ParishMaxAggregateOutputType | null
  }

  type GetParishGroupByPayload<T extends ParishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParishGroupByOutputType[P]>
            : GetScalarType<T[P], ParishGroupByOutputType[P]>
        }
      >
    >


  export type ParishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parishName?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    materials?: boolean | Parish$materialsArgs<ExtArgs>
    Rate?: boolean | Parish$RateArgs<ExtArgs>
    Supplier?: boolean | Parish$SupplierArgs<ExtArgs>
    Product?: boolean | Parish$ProductArgs<ExtArgs>
    _count?: boolean | ParishCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parish"]>

  export type ParishSelectScalar = {
    id?: boolean
    parishName?: boolean
    locationId?: boolean
  }

  export type ParishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    materials?: boolean | Parish$materialsArgs<ExtArgs>
    Rate?: boolean | Parish$RateArgs<ExtArgs>
    Supplier?: boolean | Parish$SupplierArgs<ExtArgs>
    Product?: boolean | Parish$ProductArgs<ExtArgs>
    _count?: boolean | ParishCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ParishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parish"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      Rate: Prisma.$RatePayload<ExtArgs>[]
      Supplier: Prisma.$SupplierPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parishName: string
      locationId: number
    }, ExtArgs["result"]["parish"]>
    composites: {}
  }


  type ParishGetPayload<S extends boolean | null | undefined | ParishDefaultArgs> = $Result.GetResult<Prisma.$ParishPayload, S>

  type ParishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParishFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParishCountAggregateInputType | true
    }

  export interface ParishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parish'], meta: { name: 'Parish' } }
    /**
     * Find zero or one Parish that matches the filter.
     * @param {ParishFindUniqueArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParishFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ParishFindUniqueArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Parish that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParishFindUniqueOrThrowArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParishFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Parish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindFirstArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParishFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishFindFirstArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Parish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindFirstOrThrowArgs} args - Arguments to find a Parish
     * @example
     * // Get one Parish
     * const parish = await prisma.parish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParishFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Parishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parishes
     * const parishes = await prisma.parish.findMany()
     * 
     * // Get first 10 Parishes
     * const parishes = await prisma.parish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parishWithIdOnly = await prisma.parish.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParishFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Parish.
     * @param {ParishCreateArgs} args - Arguments to create a Parish.
     * @example
     * // Create one Parish
     * const Parish = await prisma.parish.create({
     *   data: {
     *     // ... data to create a Parish
     *   }
     * })
     * 
    **/
    create<T extends ParishCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParishCreateArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Parishes.
     *     @param {ParishCreateManyArgs} args - Arguments to create many Parishes.
     *     @example
     *     // Create many Parishes
     *     const parish = await prisma.parish.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParishCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parish.
     * @param {ParishDeleteArgs} args - Arguments to delete one Parish.
     * @example
     * // Delete one Parish
     * const Parish = await prisma.parish.delete({
     *   where: {
     *     // ... filter to delete one Parish
     *   }
     * })
     * 
    **/
    delete<T extends ParishDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParishDeleteArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Parish.
     * @param {ParishUpdateArgs} args - Arguments to update one Parish.
     * @example
     * // Update one Parish
     * const parish = await prisma.parish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParishUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParishUpdateArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Parishes.
     * @param {ParishDeleteManyArgs} args - Arguments to filter Parishes to delete.
     * @example
     * // Delete a few Parishes
     * const { count } = await prisma.parish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParishDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParishDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parishes
     * const parish = await prisma.parish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParishUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParishUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parish.
     * @param {ParishUpsertArgs} args - Arguments to update or create a Parish.
     * @example
     * // Update or create a Parish
     * const parish = await prisma.parish.upsert({
     *   create: {
     *     // ... data to create a Parish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parish we want to update
     *   }
     * })
    **/
    upsert<T extends ParishUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParishUpsertArgs<ExtArgs>>
    ): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Parishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishCountArgs} args - Arguments to filter Parishes to count.
     * @example
     * // Count the number of Parishes
     * const count = await prisma.parish.count({
     *   where: {
     *     // ... the filter for the Parishes we want to count
     *   }
     * })
    **/
    count<T extends ParishCountArgs>(
      args?: Subset<T, ParishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParishAggregateArgs>(args: Subset<T, ParishAggregateArgs>): Prisma.PrismaPromise<GetParishAggregateType<T>>

    /**
     * Group by Parish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParishGroupByArgs['orderBy'] }
        : { orderBy?: ParishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parish model
   */
  readonly fields: ParishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    materials<T extends Parish$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Parish$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findMany'> | Null>;

    Rate<T extends Parish$RateArgs<ExtArgs> = {}>(args?: Subset<T, Parish$RateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findMany'> | Null>;

    Supplier<T extends Parish$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, Parish$SupplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Parish$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Parish$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Parish model
   */ 
  interface ParishFieldRefs {
    readonly id: FieldRef<"Parish", 'Int'>
    readonly parishName: FieldRef<"Parish", 'String'>
    readonly locationId: FieldRef<"Parish", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Parish findUnique
   */
  export type ParishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where: ParishWhereUniqueInput
  }


  /**
   * Parish findUniqueOrThrow
   */
  export type ParishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where: ParishWhereUniqueInput
  }


  /**
   * Parish findFirst
   */
  export type ParishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parishes.
     */
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }


  /**
   * Parish findFirstOrThrow
   */
  export type ParishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parish to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parishes.
     */
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }


  /**
   * Parish findMany
   */
  export type ParishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter, which Parishes to fetch.
     */
    where?: ParishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parishes to fetch.
     */
    orderBy?: ParishOrderByWithRelationInput | ParishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parishes.
     */
    cursor?: ParishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parishes.
     */
    skip?: number
    distinct?: ParishScalarFieldEnum | ParishScalarFieldEnum[]
  }


  /**
   * Parish create
   */
  export type ParishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The data needed to create a Parish.
     */
    data: XOR<ParishCreateInput, ParishUncheckedCreateInput>
  }


  /**
   * Parish createMany
   */
  export type ParishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parishes.
     */
    data: ParishCreateManyInput | ParishCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Parish update
   */
  export type ParishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The data needed to update a Parish.
     */
    data: XOR<ParishUpdateInput, ParishUncheckedUpdateInput>
    /**
     * Choose, which Parish to update.
     */
    where: ParishWhereUniqueInput
  }


  /**
   * Parish updateMany
   */
  export type ParishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parishes.
     */
    data: XOR<ParishUpdateManyMutationInput, ParishUncheckedUpdateManyInput>
    /**
     * Filter which Parishes to update
     */
    where?: ParishWhereInput
  }


  /**
   * Parish upsert
   */
  export type ParishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * The filter to search for the Parish to update in case it exists.
     */
    where: ParishWhereUniqueInput
    /**
     * In case the Parish found by the `where` argument doesn't exist, create a new Parish with this data.
     */
    create: XOR<ParishCreateInput, ParishUncheckedCreateInput>
    /**
     * In case the Parish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParishUpdateInput, ParishUncheckedUpdateInput>
  }


  /**
   * Parish delete
   */
  export type ParishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
    /**
     * Filter which Parish to delete.
     */
    where: ParishWhereUniqueInput
  }


  /**
   * Parish deleteMany
   */
  export type ParishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parishes to delete
     */
    where?: ParishWhereInput
  }


  /**
   * Parish.materials
   */
  export type Parish$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }


  /**
   * Parish.Rate
   */
  export type Parish$RateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    where?: RateWhereInput
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    cursor?: RateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Parish.Supplier
   */
  export type Parish$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Parish.Product
   */
  export type Parish$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Parish without action
   */
  export type ParishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parish
     */
    select?: ParishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParishInclude<ExtArgs> | null
  }



  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
    parishId: number | null
    unitsId: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
    parishId: number | null
    unitsId: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    materialName: string | null
    parishId: number | null
    unitsId: number | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    materialName: string | null
    parishId: number | null
    unitsId: number | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    materialName: number
    parishId: number
    unitsId: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
    parishId?: true
    unitsId?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
    parishId?: true
    unitsId?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    materialName?: true
    parishId?: true
    unitsId?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    materialName?: true
    parishId?: true
    unitsId?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    materialName?: true
    parishId?: true
    unitsId?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    materialName: string
    parishId: number
    unitsId: number
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialName?: boolean
    parishId?: boolean
    unitsId?: boolean
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    rates?: boolean | Material$ratesArgs<ExtArgs>
    Product?: boolean | Material$ProductArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    materialName?: boolean
    parishId?: boolean
    unitsId?: boolean
  }

  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    rates?: boolean | Material$ratesArgs<ExtArgs>
    Product?: boolean | Material$ProductArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      parish: Prisma.$ParishPayload<ExtArgs>
      units: Prisma.$UnitPayload<ExtArgs>
      rates: Prisma.$RatePayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialName: string
      parishId: number
      unitsId: number
    }, ExtArgs["result"]["material"]>
    composites: {}
  }


  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaterialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
    **/
    create<T extends MaterialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Materials.
     *     @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const material = await prisma.material.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
    **/
    delete<T extends MaterialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>
    ): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    units<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rates<T extends Material$ratesArgs<ExtArgs> = {}>(args?: Subset<T, Material$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Material$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Material$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly materialName: FieldRef<"Material", 'String'>
    readonly parishId: FieldRef<"Material", 'Int'>
    readonly unitsId: FieldRef<"Material", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }


  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }


  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }


  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }


  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }


  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }


  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }


  /**
   * Material.rates
   */
  export type Material$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    where?: RateWhereInput
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    cursor?: RateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Material.Product
   */
  export type Material$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
  }



  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    unitName: string | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    unitName: string | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    unitName: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    unitName?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    unitName?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    unitName?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    unitName: string
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitName?: boolean
    materials?: boolean | Unit$materialsArgs<ExtArgs>
    Rate?: boolean | Unit$RateArgs<ExtArgs>
    Product?: boolean | Unit$ProductArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    unitName?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | Unit$materialsArgs<ExtArgs>
    Rate?: boolean | Unit$RateArgs<ExtArgs>
    Product?: boolean | Unit$ProductArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      Rate: Prisma.$RatePayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitName: string
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }


  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
    **/
    create<T extends UnitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitCreateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Units.
     *     @param {UnitCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const unit = await prisma.unit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
    **/
    delete<T extends UnitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
    **/
    upsert<T extends UnitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    materials<T extends Unit$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findMany'> | Null>;

    Rate<T extends Unit$RateArgs<ExtArgs> = {}>(args?: Subset<T, Unit$RateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Unit$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Unit$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly unitName: FieldRef<"Unit", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }


  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }


  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }


  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }


  /**
   * Unit.materials
   */
  export type Unit$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }


  /**
   * Unit.Rate
   */
  export type Unit$RateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    where?: RateWhereInput
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    cursor?: RateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Unit.Product
   */
  export type Unit$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
  }



  /**
   * Model Rate
   */

  export type AggregateRate = {
    _count: RateCountAggregateOutputType | null
    _avg: RateAvgAggregateOutputType | null
    _sum: RateSumAggregateOutputType | null
    _min: RateMinAggregateOutputType | null
    _max: RateMaxAggregateOutputType | null
  }

  export type RateAvgAggregateOutputType = {
    id: number | null
    rateValue: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
    supplierId: number | null
  }

  export type RateSumAggregateOutputType = {
    id: number | null
    rateValue: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
    supplierId: number | null
  }

  export type RateMinAggregateOutputType = {
    id: number | null
    rateValue: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
    supplierId: number | null
  }

  export type RateMaxAggregateOutputType = {
    id: number | null
    rateValue: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
    supplierId: number | null
  }

  export type RateCountAggregateOutputType = {
    id: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    supplierId: number
    _all: number
  }


  export type RateAvgAggregateInputType = {
    id?: true
    rateValue?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    supplierId?: true
  }

  export type RateSumAggregateInputType = {
    id?: true
    rateValue?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    supplierId?: true
  }

  export type RateMinAggregateInputType = {
    id?: true
    rateValue?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    supplierId?: true
  }

  export type RateMaxAggregateInputType = {
    id?: true
    rateValue?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    supplierId?: true
  }

  export type RateCountAggregateInputType = {
    id?: true
    rateValue?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    supplierId?: true
    _all?: true
  }

  export type RateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rate to aggregate.
     */
    where?: RateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rates
    **/
    _count?: true | RateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateMaxAggregateInputType
  }

  export type GetRateAggregateType<T extends RateAggregateArgs> = {
        [P in keyof T & keyof AggregateRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRate[P]>
      : GetScalarType<T[P], AggregateRate[P]>
  }




  export type RateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateWhereInput
    orderBy?: RateOrderByWithAggregationInput | RateOrderByWithAggregationInput[]
    by: RateScalarFieldEnum[] | RateScalarFieldEnum
    having?: RateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateCountAggregateInputType | true
    _avg?: RateAvgAggregateInputType
    _sum?: RateSumAggregateInputType
    _min?: RateMinAggregateInputType
    _max?: RateMaxAggregateInputType
  }

  export type RateGroupByOutputType = {
    id: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    supplierId: number
    _count: RateCountAggregateOutputType | null
    _avg: RateAvgAggregateOutputType | null
    _sum: RateSumAggregateOutputType | null
    _min: RateMinAggregateOutputType | null
    _max: RateMaxAggregateOutputType | null
  }

  type GetRateGroupByPayload<T extends RateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateGroupByOutputType[P]>
            : GetScalarType<T[P], RateGroupByOutputType[P]>
        }
      >
    >


  export type RateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rateValue?: boolean
    parishId?: boolean
    materialId?: boolean
    unitsId?: boolean
    supplierId?: boolean
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    Product?: boolean | Rate$ProductArgs<ExtArgs>
    _count?: boolean | RateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rate"]>

  export type RateSelectScalar = {
    id?: boolean
    rateValue?: boolean
    parishId?: boolean
    materialId?: boolean
    unitsId?: boolean
    supplierId?: boolean
  }

  export type RateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    Product?: boolean | Rate$ProductArgs<ExtArgs>
    _count?: boolean | RateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rate"
    objects: {
      parish: Prisma.$ParishPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
      units: Prisma.$UnitPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rateValue: number
      parishId: number
      materialId: number
      unitsId: number
      supplierId: number
    }, ExtArgs["result"]["rate"]>
    composites: {}
  }


  type RateGetPayload<S extends boolean | null | undefined | RateDefaultArgs> = $Result.GetResult<Prisma.$RatePayload, S>

  type RateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RateCountAggregateInputType | true
    }

  export interface RateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rate'], meta: { name: 'Rate' } }
    /**
     * Find zero or one Rate that matches the filter.
     * @param {RateFindUniqueArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RateFindUniqueArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RateFindUniqueOrThrowArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateFindFirstArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RateFindFirstArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateFindFirstOrThrowArgs} args - Arguments to find a Rate
     * @example
     * // Get one Rate
     * const rate = await prisma.rate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rates
     * const rates = await prisma.rate.findMany()
     * 
     * // Get first 10 Rates
     * const rates = await prisma.rate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateWithIdOnly = await prisma.rate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rate.
     * @param {RateCreateArgs} args - Arguments to create a Rate.
     * @example
     * // Create one Rate
     * const Rate = await prisma.rate.create({
     *   data: {
     *     // ... data to create a Rate
     *   }
     * })
     * 
    **/
    create<T extends RateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RateCreateArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rates.
     *     @param {RateCreateManyArgs} args - Arguments to create many Rates.
     *     @example
     *     // Create many Rates
     *     const rate = await prisma.rate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rate.
     * @param {RateDeleteArgs} args - Arguments to delete one Rate.
     * @example
     * // Delete one Rate
     * const Rate = await prisma.rate.delete({
     *   where: {
     *     // ... filter to delete one Rate
     *   }
     * })
     * 
    **/
    delete<T extends RateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RateDeleteArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rate.
     * @param {RateUpdateArgs} args - Arguments to update one Rate.
     * @example
     * // Update one Rate
     * const rate = await prisma.rate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RateUpdateArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rates.
     * @param {RateDeleteManyArgs} args - Arguments to filter Rates to delete.
     * @example
     * // Delete a few Rates
     * const { count } = await prisma.rate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rates
     * const rate = await prisma.rate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rate.
     * @param {RateUpsertArgs} args - Arguments to update or create a Rate.
     * @example
     * // Update or create a Rate
     * const rate = await prisma.rate.upsert({
     *   create: {
     *     // ... data to create a Rate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rate we want to update
     *   }
     * })
    **/
    upsert<T extends RateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RateUpsertArgs<ExtArgs>>
    ): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCountArgs} args - Arguments to filter Rates to count.
     * @example
     * // Count the number of Rates
     * const count = await prisma.rate.count({
     *   where: {
     *     // ... the filter for the Rates we want to count
     *   }
     * })
    **/
    count<T extends RateCountArgs>(
      args?: Subset<T, RateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateAggregateArgs>(args: Subset<T, RateAggregateArgs>): Prisma.PrismaPromise<GetRateAggregateType<T>>

    /**
     * Group by Rate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateGroupByArgs['orderBy'] }
        : { orderBy?: RateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rate model
   */
  readonly fields: RateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    units<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Product<T extends Rate$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Rate$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Rate model
   */ 
  interface RateFieldRefs {
    readonly id: FieldRef<"Rate", 'Int'>
    readonly rateValue: FieldRef<"Rate", 'Float'>
    readonly parishId: FieldRef<"Rate", 'Int'>
    readonly materialId: FieldRef<"Rate", 'Int'>
    readonly unitsId: FieldRef<"Rate", 'Int'>
    readonly supplierId: FieldRef<"Rate", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Rate findUnique
   */
  export type RateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter, which Rate to fetch.
     */
    where: RateWhereUniqueInput
  }


  /**
   * Rate findUniqueOrThrow
   */
  export type RateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter, which Rate to fetch.
     */
    where: RateWhereUniqueInput
  }


  /**
   * Rate findFirst
   */
  export type RateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter, which Rate to fetch.
     */
    where?: RateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rates.
     */
    cursor?: RateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rates.
     */
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Rate findFirstOrThrow
   */
  export type RateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter, which Rate to fetch.
     */
    where?: RateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rates.
     */
    cursor?: RateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rates.
     */
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Rate findMany
   */
  export type RateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter, which Rates to fetch.
     */
    where?: RateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rates to fetch.
     */
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rates.
     */
    cursor?: RateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rates.
     */
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Rate create
   */
  export type RateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * The data needed to create a Rate.
     */
    data: XOR<RateCreateInput, RateUncheckedCreateInput>
  }


  /**
   * Rate createMany
   */
  export type RateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rates.
     */
    data: RateCreateManyInput | RateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Rate update
   */
  export type RateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * The data needed to update a Rate.
     */
    data: XOR<RateUpdateInput, RateUncheckedUpdateInput>
    /**
     * Choose, which Rate to update.
     */
    where: RateWhereUniqueInput
  }


  /**
   * Rate updateMany
   */
  export type RateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rates.
     */
    data: XOR<RateUpdateManyMutationInput, RateUncheckedUpdateManyInput>
    /**
     * Filter which Rates to update
     */
    where?: RateWhereInput
  }


  /**
   * Rate upsert
   */
  export type RateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * The filter to search for the Rate to update in case it exists.
     */
    where: RateWhereUniqueInput
    /**
     * In case the Rate found by the `where` argument doesn't exist, create a new Rate with this data.
     */
    create: XOR<RateCreateInput, RateUncheckedCreateInput>
    /**
     * In case the Rate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateUpdateInput, RateUncheckedUpdateInput>
  }


  /**
   * Rate delete
   */
  export type RateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    /**
     * Filter which Rate to delete.
     */
    where: RateWhereUniqueInput
  }


  /**
   * Rate deleteMany
   */
  export type RateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rates to delete
     */
    where?: RateWhereInput
  }


  /**
   * Rate.Product
   */
  export type Rate$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Rate without action
   */
  export type RateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
  }



  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    parishId: number | null
    locationId: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    parishId: number | null
    locationId: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    supplierName: string | null
    parishId: number | null
    locationId: number | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    supplierName: string | null
    parishId: number | null
    locationId: number | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    supplierName: number
    parishId: number
    locationId: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    parishId?: true
    locationId?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    parishId?: true
    locationId?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    supplierName?: true
    parishId?: true
    locationId?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    supplierName?: true
    parishId?: true
    locationId?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    supplierName?: true
    parishId?: true
    locationId?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    supplierName: string
    parishId: number
    locationId: number
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    parishId?: boolean
    locationId?: boolean
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    locationName?: boolean | LocationDefaultArgs<ExtArgs>
    rates?: boolean | Supplier$ratesArgs<ExtArgs>
    Product?: boolean | Supplier$ProductArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    supplierName?: boolean
    parishId?: boolean
    locationId?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    locationName?: boolean | LocationDefaultArgs<ExtArgs>
    rates?: boolean | Supplier$ratesArgs<ExtArgs>
    Product?: boolean | Supplier$ProductArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      parish: Prisma.$ParishPayload<ExtArgs>
      locationName: Prisma.$LocationPayload<ExtArgs>
      rates: Prisma.$RatePayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierName: string
      parishId: number
      locationId: number
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    locationName<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rates<T extends Supplier$ratesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Supplier$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly supplierName: FieldRef<"Supplier", 'String'>
    readonly parishId: FieldRef<"Supplier", 'Int'>
    readonly locationId: FieldRef<"Supplier", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier.rates
   */
  export type Supplier$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate
     */
    select?: RateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateInclude<ExtArgs> | null
    where?: RateWhereInput
    orderBy?: RateOrderByWithRelationInput | RateOrderByWithRelationInput[]
    cursor?: RateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateScalarFieldEnum | RateScalarFieldEnum[]
  }


  /**
   * Supplier.Product
   */
  export type Supplier$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    rateId: number | null
    supplierId: number | null
    locationId: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    rateId: number | null
    supplierId: number | null
    locationId: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    rateId: number | null
    supplierId: number | null
    locationId: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    rateId: number | null
    supplierId: number | null
    locationId: number | null
    parishId: number | null
    materialId: number | null
    unitsId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    rateId?: true
    supplierId?: true
    locationId?: true
    parishId?: true
    materialId?: true
    unitsId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    rateId?: true
    supplierId?: true
    locationId?: true
    parishId?: true
    materialId?: true
    unitsId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    rateId?: true
    supplierId?: true
    locationId?: true
    parishId?: true
    materialId?: true
    unitsId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    rateId?: true
    supplierId?: true
    locationId?: true
    parishId?: true
    materialId?: true
    unitsId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    rateId?: true
    supplierId?: true
    locationId?: true
    parishId?: true
    materialId?: true
    unitsId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rateId?: boolean
    supplierId?: boolean
    locationId?: boolean
    parishId?: boolean
    materialId?: boolean
    unitsId?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    locationName?: boolean | LocationDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    rateDetails?: boolean | RateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    rateId?: boolean
    supplierId?: boolean
    locationId?: boolean
    parishId?: boolean
    materialId?: boolean
    unitsId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    locationName?: boolean | LocationDefaultArgs<ExtArgs>
    parish?: boolean | ParishDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    units?: boolean | UnitDefaultArgs<ExtArgs>
    rateDetails?: boolean | RateDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      locationName: Prisma.$LocationPayload<ExtArgs>
      parish: Prisma.$ParishPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
      units: Prisma.$UnitPayload<ExtArgs>
      rateDetails: Prisma.$RatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rateId: number
      supplierId: number
      locationId: number
      parishId: number
      materialId: number
      unitsId: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    locationName<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parish<T extends ParishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParishDefaultArgs<ExtArgs>>): Prisma__ParishClient<$Result.GetResult<Prisma.$ParishPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    units<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rateDetails<T extends RateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RateDefaultArgs<ExtArgs>>): Prisma__RateClient<$Result.GetResult<Prisma.$RatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly rateId: FieldRef<"Product", 'Int'>
    readonly supplierId: FieldRef<"Product", 'Int'>
    readonly locationId: FieldRef<"Product", 'Int'>
    readonly parishId: FieldRef<"Product", 'Int'>
    readonly materialId: FieldRef<"Product", 'Int'>
    readonly unitsId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phone: 'phone',
    locationId: 'locationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    regionName: 'regionName'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    locationName: 'locationName',
    regionId: 'regionId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ParishScalarFieldEnum: {
    id: 'id',
    parishName: 'parishName',
    locationId: 'locationId'
  };

  export type ParishScalarFieldEnum = (typeof ParishScalarFieldEnum)[keyof typeof ParishScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    materialName: 'materialName',
    parishId: 'parishId',
    unitsId: 'unitsId'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    unitName: 'unitName'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const RateScalarFieldEnum: {
    id: 'id',
    rateValue: 'rateValue',
    parishId: 'parishId',
    materialId: 'materialId',
    unitsId: 'unitsId',
    supplierId: 'supplierId'
  };

  export type RateScalarFieldEnum = (typeof RateScalarFieldEnum)[keyof typeof RateScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    supplierName: 'supplierName',
    parishId: 'parishId',
    locationId: 'locationId'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    rateId: 'rateId',
    supplierId: 'supplierId',
    locationId: 'locationId',
    parishId: 'parishId',
    materialId: 'materialId',
    unitsId: 'unitsId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    locationId?: IntNullableFilter<"User"> | number | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    locationId?: IntNullableFilter<"User"> | number | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    locationId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    regionName?: StringFilter<"Region"> | string
    locations?: LocationListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    regionName?: SortOrder
    locations?: LocationOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    regionName?: StringFilter<"Region"> | string
    locations?: LocationListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    regionName?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    regionName?: StringWithAggregatesFilter<"Region"> | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    locationName?: StringFilter<"Location"> | string
    regionId?: IntFilter<"Location"> | number
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    parishes?: ParishListRelationFilter
    User?: UserListRelationFilter
    Product?: ProductListRelationFilter
    Supplier?: SupplierListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    locationName?: SortOrder
    regionId?: SortOrder
    region?: RegionOrderByWithRelationInput
    parishes?: ParishOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
    Supplier?: SupplierOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    locationName?: StringFilter<"Location"> | string
    regionId?: IntFilter<"Location"> | number
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    parishes?: ParishListRelationFilter
    User?: UserListRelationFilter
    Product?: ProductListRelationFilter
    Supplier?: SupplierListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    locationName?: SortOrder
    regionId?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    locationName?: StringWithAggregatesFilter<"Location"> | string
    regionId?: IntWithAggregatesFilter<"Location"> | number
  }

  export type ParishWhereInput = {
    AND?: ParishWhereInput | ParishWhereInput[]
    OR?: ParishWhereInput[]
    NOT?: ParishWhereInput | ParishWhereInput[]
    id?: IntFilter<"Parish"> | number
    parishName?: StringFilter<"Parish"> | string
    locationId?: IntFilter<"Parish"> | number
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    materials?: MaterialListRelationFilter
    Rate?: RateListRelationFilter
    Supplier?: SupplierListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type ParishOrderByWithRelationInput = {
    id?: SortOrder
    parishName?: SortOrder
    locationId?: SortOrder
    location?: LocationOrderByWithRelationInput
    materials?: MaterialOrderByRelationAggregateInput
    Rate?: RateOrderByRelationAggregateInput
    Supplier?: SupplierOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type ParishWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParishWhereInput | ParishWhereInput[]
    OR?: ParishWhereInput[]
    NOT?: ParishWhereInput | ParishWhereInput[]
    parishName?: StringFilter<"Parish"> | string
    locationId?: IntFilter<"Parish"> | number
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    materials?: MaterialListRelationFilter
    Rate?: RateListRelationFilter
    Supplier?: SupplierListRelationFilter
    Product?: ProductListRelationFilter
  }, "id">

  export type ParishOrderByWithAggregationInput = {
    id?: SortOrder
    parishName?: SortOrder
    locationId?: SortOrder
    _count?: ParishCountOrderByAggregateInput
    _avg?: ParishAvgOrderByAggregateInput
    _max?: ParishMaxOrderByAggregateInput
    _min?: ParishMinOrderByAggregateInput
    _sum?: ParishSumOrderByAggregateInput
  }

  export type ParishScalarWhereWithAggregatesInput = {
    AND?: ParishScalarWhereWithAggregatesInput | ParishScalarWhereWithAggregatesInput[]
    OR?: ParishScalarWhereWithAggregatesInput[]
    NOT?: ParishScalarWhereWithAggregatesInput | ParishScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parish"> | number
    parishName?: StringWithAggregatesFilter<"Parish"> | string
    locationId?: IntWithAggregatesFilter<"Parish"> | number
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    materialName?: StringFilter<"Material"> | string
    parishId?: IntFilter<"Material"> | number
    unitsId?: IntFilter<"Material"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    rates?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    materialName?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
    parish?: ParishOrderByWithRelationInput
    units?: UnitOrderByWithRelationInput
    rates?: RateOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    materialName?: StringFilter<"Material"> | string
    parishId?: IntFilter<"Material"> | number
    unitsId?: IntFilter<"Material"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    rates?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    materialName?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    materialName?: StringWithAggregatesFilter<"Material"> | string
    parishId?: IntWithAggregatesFilter<"Material"> | number
    unitsId?: IntWithAggregatesFilter<"Material"> | number
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    unitName?: StringFilter<"Unit"> | string
    materials?: MaterialListRelationFilter
    Rate?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    unitName?: SortOrder
    materials?: MaterialOrderByRelationAggregateInput
    Rate?: RateOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    unitName?: StringFilter<"Unit"> | string
    materials?: MaterialListRelationFilter
    Rate?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    unitName?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    unitName?: StringWithAggregatesFilter<"Unit"> | string
  }

  export type RateWhereInput = {
    AND?: RateWhereInput | RateWhereInput[]
    OR?: RateWhereInput[]
    NOT?: RateWhereInput | RateWhereInput[]
    id?: IntFilter<"Rate"> | number
    rateValue?: FloatFilter<"Rate"> | number
    parishId?: IntFilter<"Rate"> | number
    materialId?: IntFilter<"Rate"> | number
    unitsId?: IntFilter<"Rate"> | number
    supplierId?: IntFilter<"Rate"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    Product?: ProductListRelationFilter
  }

  export type RateOrderByWithRelationInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
    parish?: ParishOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    units?: UnitOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type RateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RateWhereInput | RateWhereInput[]
    OR?: RateWhereInput[]
    NOT?: RateWhereInput | RateWhereInput[]
    rateValue?: FloatFilter<"Rate"> | number
    parishId?: IntFilter<"Rate"> | number
    materialId?: IntFilter<"Rate"> | number
    unitsId?: IntFilter<"Rate"> | number
    supplierId?: IntFilter<"Rate"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    Product?: ProductListRelationFilter
  }, "id">

  export type RateOrderByWithAggregationInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
    _count?: RateCountOrderByAggregateInput
    _avg?: RateAvgOrderByAggregateInput
    _max?: RateMaxOrderByAggregateInput
    _min?: RateMinOrderByAggregateInput
    _sum?: RateSumOrderByAggregateInput
  }

  export type RateScalarWhereWithAggregatesInput = {
    AND?: RateScalarWhereWithAggregatesInput | RateScalarWhereWithAggregatesInput[]
    OR?: RateScalarWhereWithAggregatesInput[]
    NOT?: RateScalarWhereWithAggregatesInput | RateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rate"> | number
    rateValue?: FloatWithAggregatesFilter<"Rate"> | number
    parishId?: IntWithAggregatesFilter<"Rate"> | number
    materialId?: IntWithAggregatesFilter<"Rate"> | number
    unitsId?: IntWithAggregatesFilter<"Rate"> | number
    supplierId?: IntWithAggregatesFilter<"Rate"> | number
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    supplierName?: StringFilter<"Supplier"> | string
    parishId?: IntFilter<"Supplier"> | number
    locationId?: IntFilter<"Supplier"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    locationName?: XOR<LocationRelationFilter, LocationWhereInput>
    rates?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
    parish?: ParishOrderByWithRelationInput
    locationName?: LocationOrderByWithRelationInput
    rates?: RateOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplierName?: StringFilter<"Supplier"> | string
    parishId?: IntFilter<"Supplier"> | number
    locationId?: IntFilter<"Supplier"> | number
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    locationName?: XOR<LocationRelationFilter, LocationWhereInput>
    rates?: RateListRelationFilter
    Product?: ProductListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    supplierName?: StringWithAggregatesFilter<"Supplier"> | string
    parishId?: IntWithAggregatesFilter<"Supplier"> | number
    locationId?: IntWithAggregatesFilter<"Supplier"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    rateId?: IntFilter<"Product"> | number
    supplierId?: IntFilter<"Product"> | number
    locationId?: IntFilter<"Product"> | number
    parishId?: IntFilter<"Product"> | number
    materialId?: IntFilter<"Product"> | number
    unitsId?: IntFilter<"Product"> | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    locationName?: XOR<LocationRelationFilter, LocationWhereInput>
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    rateDetails?: XOR<RateRelationFilter, RateWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    locationName?: LocationOrderByWithRelationInput
    parish?: ParishOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    units?: UnitOrderByWithRelationInput
    rateDetails?: RateOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    rateId?: IntFilter<"Product"> | number
    supplierId?: IntFilter<"Product"> | number
    locationId?: IntFilter<"Product"> | number
    parishId?: IntFilter<"Product"> | number
    materialId?: IntFilter<"Product"> | number
    unitsId?: IntFilter<"Product"> | number
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    locationName?: XOR<LocationRelationFilter, LocationWhereInput>
    parish?: XOR<ParishRelationFilter, ParishWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    units?: XOR<UnitRelationFilter, UnitWhereInput>
    rateDetails?: XOR<RateRelationFilter, RateWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    rateId?: IntWithAggregatesFilter<"Product"> | number
    supplierId?: IntWithAggregatesFilter<"Product"> | number
    locationId?: IntWithAggregatesFilter<"Product"> | number
    parishId?: IntWithAggregatesFilter<"Product"> | number
    materialId?: IntWithAggregatesFilter<"Product"> | number
    unitsId?: IntWithAggregatesFilter<"Product"> | number
  }

  export type UserCreateInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    location?: LocationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    locationId?: number | null
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    locationId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RegionCreateInput = {
    regionName: string
    locations?: LocationCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    regionName: string
    locations?: LocationUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    locations?: LocationUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    locations?: LocationUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    regionName: string
  }

  export type RegionUpdateManyMutationInput = {
    regionName?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateInput = {
    locationName: string
    region: RegionCreateNestedOneWithoutLocationsInput
    parishes?: ParishCreateNestedManyWithoutLocationInput
    User?: UserCreateNestedManyWithoutLocationInput
    Product?: ProductCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    locationName: string
    regionId: number
    parishes?: ParishUncheckedCreateNestedManyWithoutLocationInput
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
    Product?: ProductUncheckedCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUpdateInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    parishes?: ParishUpdateManyWithoutLocationNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
    Product?: ProductUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
    parishes?: ParishUncheckedUpdateManyWithoutLocationNestedInput
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
    Product?: ProductUncheckedUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    locationName: string
    regionId: number
  }

  export type LocationUpdateManyMutationInput = {
    locationName?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type ParishCreateInput = {
    parishName: string
    location: LocationCreateNestedOneWithoutParishesInput
    materials?: MaterialCreateNestedManyWithoutParishInput
    Rate?: RateCreateNestedManyWithoutParishInput
    Supplier?: SupplierCreateNestedManyWithoutParishInput
    Product?: ProductCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateInput = {
    id?: number
    parishName: string
    locationId: number
    materials?: MaterialUncheckedCreateNestedManyWithoutParishInput
    Rate?: RateUncheckedCreateNestedManyWithoutParishInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutParishInput
    Product?: ProductUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishUpdateInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutParishesNestedInput
    materials?: MaterialUpdateManyWithoutParishNestedInput
    Rate?: RateUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUpdateManyWithoutParishNestedInput
    Product?: ProductUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUncheckedUpdateManyWithoutParishNestedInput
    Rate?: RateUncheckedUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutParishNestedInput
    Product?: ProductUncheckedUpdateManyWithoutParishNestedInput
  }

  export type ParishCreateManyInput = {
    id?: number
    parishName: string
    locationId: number
  }

  export type ParishUpdateManyMutationInput = {
    parishName?: StringFieldUpdateOperationsInput | string
  }

  export type ParishUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateInput = {
    materialName: string
    parish: ParishCreateNestedOneWithoutMaterialsInput
    units: UnitCreateNestedOneWithoutMaterialsInput
    rates?: RateCreateNestedManyWithoutMaterialInput
    Product?: ProductCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    materialName: string
    parishId: number
    unitsId: number
    rates?: RateUncheckedCreateNestedManyWithoutMaterialInput
    Product?: ProductUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutMaterialsNestedInput
    units?: UnitUpdateOneRequiredWithoutMaterialsNestedInput
    rates?: RateUpdateManyWithoutMaterialNestedInput
    Product?: ProductUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutMaterialNestedInput
    Product?: ProductUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    materialName: string
    parishId: number
    unitsId: number
  }

  export type MaterialUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type UnitCreateInput = {
    unitName: string
    materials?: MaterialCreateNestedManyWithoutUnitsInput
    Rate?: RateCreateNestedManyWithoutUnitsInput
    Product?: ProductCreateNestedManyWithoutUnitsInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    unitName: string
    materials?: MaterialUncheckedCreateNestedManyWithoutUnitsInput
    Rate?: RateUncheckedCreateNestedManyWithoutUnitsInput
    Product?: ProductUncheckedCreateNestedManyWithoutUnitsInput
  }

  export type UnitUpdateInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUpdateManyWithoutUnitsNestedInput
    Rate?: RateUpdateManyWithoutUnitsNestedInput
    Product?: ProductUpdateManyWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutUnitsNestedInput
    Rate?: RateUncheckedUpdateManyWithoutUnitsNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUnitsNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    unitName: string
  }

  export type UnitUpdateManyMutationInput = {
    unitName?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
  }

  export type RateCreateInput = {
    rateValue: number
    parish: ParishCreateNestedOneWithoutRateInput
    material: MaterialCreateNestedOneWithoutRatesInput
    units: UnitCreateNestedOneWithoutRateInput
    supplier: SupplierCreateNestedOneWithoutRatesInput
    Product?: ProductCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUncheckedCreateInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    supplierId: number
    Product?: ProductUncheckedCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUpdateInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    parish?: ParishUpdateOneRequiredWithoutRateNestedInput
    material?: MaterialUpdateOneRequiredWithoutRatesNestedInput
    units?: UnitUpdateOneRequiredWithoutRateNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutRatesNestedInput
    Product?: ProductUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateCreateManyInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    supplierId: number
  }

  export type RateUpdateManyMutationInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
  }

  export type RateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierCreateInput = {
    supplierName: string
    parish: ParishCreateNestedOneWithoutSupplierInput
    locationName: LocationCreateNestedOneWithoutSupplierInput
    rates?: RateCreateNestedManyWithoutSupplierInput
    Product?: ProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    supplierName: string
    parishId: number
    locationId: number
    rates?: RateUncheckedCreateNestedManyWithoutSupplierInput
    Product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutSupplierNestedInput
    locationName?: LocationUpdateOneRequiredWithoutSupplierNestedInput
    rates?: RateUpdateManyWithoutSupplierNestedInput
    Product?: ProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutSupplierNestedInput
    Product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    supplierName: string
    parishId: number
    locationId: number
  }

  export type SupplierUpdateManyMutationInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    locationName: LocationCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductUpdateInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductUpdateManyMutationInput = {

  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    locationId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    locationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    locationId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type ParishListRelationFilter = {
    every?: ParishWhereInput
    some?: ParishWhereInput
    none?: ParishWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type ParishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    regionId?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    regionId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    regionId?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type RateListRelationFilter = {
    every?: RateWhereInput
    some?: RateWhereInput
    none?: RateWhereInput
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParishCountOrderByAggregateInput = {
    id?: SortOrder
    parishName?: SortOrder
    locationId?: SortOrder
  }

  export type ParishAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type ParishMaxOrderByAggregateInput = {
    id?: SortOrder
    parishName?: SortOrder
    locationId?: SortOrder
  }

  export type ParishMinOrderByAggregateInput = {
    id?: SortOrder
    parishName?: SortOrder
    locationId?: SortOrder
  }

  export type ParishSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type ParishRelationFilter = {
    is?: ParishWhereInput
    isNot?: ParishWhereInput
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    materialName?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    unitsId?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MaterialRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type RateCountOrderByAggregateInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
  }

  export type RateAvgOrderByAggregateInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
  }

  export type RateMaxOrderByAggregateInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
  }

  export type RateMinOrderByAggregateInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
  }

  export type RateSumOrderByAggregateInput = {
    id?: SortOrder
    rateValue?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
    supplierId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    parishId?: SortOrder
    locationId?: SortOrder
  }

  export type RateRelationFilter = {
    is?: RateWhereInput
    isNot?: RateWhereInput
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    rateId?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    parishId?: SortOrder
    materialId?: SortOrder
    unitsId?: SortOrder
  }

  export type LocationCreateNestedOneWithoutUserInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    connect?: LocationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type LocationUpdateOneWithoutUserNestedInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    upsert?: LocationUpsertWithoutUserInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUserInput, LocationUpdateWithoutUserInput>, LocationUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocationCreateNestedManyWithoutRegionInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUpdateManyWithoutRegionNestedInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutRegionInput | LocationUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutRegionInput | LocationUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutRegionInput | LocationUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutRegionInput | LocationUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutRegionInput | LocationUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutRegionInput | LocationUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutLocationsInput = {
    create?: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLocationsInput
    connect?: RegionWhereUniqueInput
  }

  export type ParishCreateNestedManyWithoutLocationInput = {
    create?: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput> | ParishCreateWithoutLocationInput[] | ParishUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ParishCreateOrConnectWithoutLocationInput | ParishCreateOrConnectWithoutLocationInput[]
    createMany?: ParishCreateManyLocationInputEnvelope
    connect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutLocationNameInput = {
    create?: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput> | ProductCreateWithoutLocationNameInput[] | ProductUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationNameInput | ProductCreateOrConnectWithoutLocationNameInput[]
    createMany?: ProductCreateManyLocationNameInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutLocationNameInput = {
    create?: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput> | SupplierCreateWithoutLocationNameInput[] | SupplierUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutLocationNameInput | SupplierCreateOrConnectWithoutLocationNameInput[]
    createMany?: SupplierCreateManyLocationNameInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type ParishUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput> | ParishCreateWithoutLocationInput[] | ParishUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ParishCreateOrConnectWithoutLocationInput | ParishCreateOrConnectWithoutLocationInput[]
    createMany?: ParishCreateManyLocationInputEnvelope
    connect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutLocationNameInput = {
    create?: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput> | ProductCreateWithoutLocationNameInput[] | ProductUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationNameInput | ProductCreateOrConnectWithoutLocationNameInput[]
    createMany?: ProductCreateManyLocationNameInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutLocationNameInput = {
    create?: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput> | SupplierCreateWithoutLocationNameInput[] | SupplierUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutLocationNameInput | SupplierCreateOrConnectWithoutLocationNameInput[]
    createMany?: SupplierCreateManyLocationNameInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLocationsInput
    upsert?: RegionUpsertWithoutLocationsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutLocationsInput, RegionUpdateWithoutLocationsInput>, RegionUncheckedUpdateWithoutLocationsInput>
  }

  export type ParishUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput> | ParishCreateWithoutLocationInput[] | ParishUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ParishCreateOrConnectWithoutLocationInput | ParishCreateOrConnectWithoutLocationInput[]
    upsert?: ParishUpsertWithWhereUniqueWithoutLocationInput | ParishUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ParishCreateManyLocationInputEnvelope
    set?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    disconnect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    delete?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    connect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    update?: ParishUpdateWithWhereUniqueWithoutLocationInput | ParishUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ParishUpdateManyWithWhereWithoutLocationInput | ParishUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ParishScalarWhereInput | ParishScalarWhereInput[]
  }

  export type UserUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutLocationNameNestedInput = {
    create?: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput> | ProductCreateWithoutLocationNameInput[] | ProductUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationNameInput | ProductCreateOrConnectWithoutLocationNameInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationNameInput | ProductUpsertWithWhereUniqueWithoutLocationNameInput[]
    createMany?: ProductCreateManyLocationNameInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationNameInput | ProductUpdateWithWhereUniqueWithoutLocationNameInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationNameInput | ProductUpdateManyWithWhereWithoutLocationNameInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutLocationNameNestedInput = {
    create?: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput> | SupplierCreateWithoutLocationNameInput[] | SupplierUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutLocationNameInput | SupplierCreateOrConnectWithoutLocationNameInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutLocationNameInput | SupplierUpsertWithWhereUniqueWithoutLocationNameInput[]
    createMany?: SupplierCreateManyLocationNameInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutLocationNameInput | SupplierUpdateWithWhereUniqueWithoutLocationNameInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutLocationNameInput | SupplierUpdateManyWithWhereWithoutLocationNameInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type ParishUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput> | ParishCreateWithoutLocationInput[] | ParishUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ParishCreateOrConnectWithoutLocationInput | ParishCreateOrConnectWithoutLocationInput[]
    upsert?: ParishUpsertWithWhereUniqueWithoutLocationInput | ParishUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ParishCreateManyLocationInputEnvelope
    set?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    disconnect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    delete?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    connect?: ParishWhereUniqueInput | ParishWhereUniqueInput[]
    update?: ParishUpdateWithWhereUniqueWithoutLocationInput | ParishUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ParishUpdateManyWithWhereWithoutLocationInput | ParishUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ParishScalarWhereInput | ParishScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutLocationNameNestedInput = {
    create?: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput> | ProductCreateWithoutLocationNameInput[] | ProductUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationNameInput | ProductCreateOrConnectWithoutLocationNameInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationNameInput | ProductUpsertWithWhereUniqueWithoutLocationNameInput[]
    createMany?: ProductCreateManyLocationNameInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationNameInput | ProductUpdateWithWhereUniqueWithoutLocationNameInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationNameInput | ProductUpdateManyWithWhereWithoutLocationNameInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutLocationNameNestedInput = {
    create?: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput> | SupplierCreateWithoutLocationNameInput[] | SupplierUncheckedCreateWithoutLocationNameInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutLocationNameInput | SupplierCreateOrConnectWithoutLocationNameInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutLocationNameInput | SupplierUpsertWithWhereUniqueWithoutLocationNameInput[]
    createMany?: SupplierCreateManyLocationNameInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutLocationNameInput | SupplierUpdateWithWhereUniqueWithoutLocationNameInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutLocationNameInput | SupplierUpdateManyWithWhereWithoutLocationNameInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutParishesInput = {
    create?: XOR<LocationCreateWithoutParishesInput, LocationUncheckedCreateWithoutParishesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutParishesInput
    connect?: LocationWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutParishInput = {
    create?: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput> | MaterialCreateWithoutParishInput[] | MaterialUncheckedCreateWithoutParishInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutParishInput | MaterialCreateOrConnectWithoutParishInput[]
    createMany?: MaterialCreateManyParishInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RateCreateNestedManyWithoutParishInput = {
    create?: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput> | RateCreateWithoutParishInput[] | RateUncheckedCreateWithoutParishInput[]
    connectOrCreate?: RateCreateOrConnectWithoutParishInput | RateCreateOrConnectWithoutParishInput[]
    createMany?: RateCreateManyParishInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutParishInput = {
    create?: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput> | SupplierCreateWithoutParishInput[] | SupplierUncheckedCreateWithoutParishInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutParishInput | SupplierCreateOrConnectWithoutParishInput[]
    createMany?: SupplierCreateManyParishInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutParishInput = {
    create?: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput> | ProductCreateWithoutParishInput[] | ProductUncheckedCreateWithoutParishInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutParishInput | ProductCreateOrConnectWithoutParishInput[]
    createMany?: ProductCreateManyParishInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutParishInput = {
    create?: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput> | MaterialCreateWithoutParishInput[] | MaterialUncheckedCreateWithoutParishInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutParishInput | MaterialCreateOrConnectWithoutParishInput[]
    createMany?: MaterialCreateManyParishInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RateUncheckedCreateNestedManyWithoutParishInput = {
    create?: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput> | RateCreateWithoutParishInput[] | RateUncheckedCreateWithoutParishInput[]
    connectOrCreate?: RateCreateOrConnectWithoutParishInput | RateCreateOrConnectWithoutParishInput[]
    createMany?: RateCreateManyParishInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutParishInput = {
    create?: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput> | SupplierCreateWithoutParishInput[] | SupplierUncheckedCreateWithoutParishInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutParishInput | SupplierCreateOrConnectWithoutParishInput[]
    createMany?: SupplierCreateManyParishInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutParishInput = {
    create?: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput> | ProductCreateWithoutParishInput[] | ProductUncheckedCreateWithoutParishInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutParishInput | ProductCreateOrConnectWithoutParishInput[]
    createMany?: ProductCreateManyParishInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutParishesNestedInput = {
    create?: XOR<LocationCreateWithoutParishesInput, LocationUncheckedCreateWithoutParishesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutParishesInput
    upsert?: LocationUpsertWithoutParishesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutParishesInput, LocationUpdateWithoutParishesInput>, LocationUncheckedUpdateWithoutParishesInput>
  }

  export type MaterialUpdateManyWithoutParishNestedInput = {
    create?: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput> | MaterialCreateWithoutParishInput[] | MaterialUncheckedCreateWithoutParishInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutParishInput | MaterialCreateOrConnectWithoutParishInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutParishInput | MaterialUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: MaterialCreateManyParishInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutParishInput | MaterialUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutParishInput | MaterialUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RateUpdateManyWithoutParishNestedInput = {
    create?: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput> | RateCreateWithoutParishInput[] | RateUncheckedCreateWithoutParishInput[]
    connectOrCreate?: RateCreateOrConnectWithoutParishInput | RateCreateOrConnectWithoutParishInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutParishInput | RateUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: RateCreateManyParishInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutParishInput | RateUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: RateUpdateManyWithWhereWithoutParishInput | RateUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutParishNestedInput = {
    create?: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput> | SupplierCreateWithoutParishInput[] | SupplierUncheckedCreateWithoutParishInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutParishInput | SupplierCreateOrConnectWithoutParishInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutParishInput | SupplierUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: SupplierCreateManyParishInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutParishInput | SupplierUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutParishInput | SupplierUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutParishNestedInput = {
    create?: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput> | ProductCreateWithoutParishInput[] | ProductUncheckedCreateWithoutParishInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutParishInput | ProductCreateOrConnectWithoutParishInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutParishInput | ProductUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: ProductCreateManyParishInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutParishInput | ProductUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutParishInput | ProductUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutParishNestedInput = {
    create?: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput> | MaterialCreateWithoutParishInput[] | MaterialUncheckedCreateWithoutParishInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutParishInput | MaterialCreateOrConnectWithoutParishInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutParishInput | MaterialUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: MaterialCreateManyParishInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutParishInput | MaterialUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutParishInput | MaterialUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RateUncheckedUpdateManyWithoutParishNestedInput = {
    create?: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput> | RateCreateWithoutParishInput[] | RateUncheckedCreateWithoutParishInput[]
    connectOrCreate?: RateCreateOrConnectWithoutParishInput | RateCreateOrConnectWithoutParishInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutParishInput | RateUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: RateCreateManyParishInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutParishInput | RateUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: RateUpdateManyWithWhereWithoutParishInput | RateUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutParishNestedInput = {
    create?: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput> | SupplierCreateWithoutParishInput[] | SupplierUncheckedCreateWithoutParishInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutParishInput | SupplierCreateOrConnectWithoutParishInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutParishInput | SupplierUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: SupplierCreateManyParishInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutParishInput | SupplierUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutParishInput | SupplierUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutParishNestedInput = {
    create?: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput> | ProductCreateWithoutParishInput[] | ProductUncheckedCreateWithoutParishInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutParishInput | ProductCreateOrConnectWithoutParishInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutParishInput | ProductUpsertWithWhereUniqueWithoutParishInput[]
    createMany?: ProductCreateManyParishInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutParishInput | ProductUpdateWithWhereUniqueWithoutParishInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutParishInput | ProductUpdateManyWithWhereWithoutParishInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ParishCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<ParishCreateWithoutMaterialsInput, ParishUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ParishCreateOrConnectWithoutMaterialsInput
    connect?: ParishWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<UnitCreateWithoutMaterialsInput, UnitUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMaterialsInput
    connect?: UnitWhereUniqueInput
  }

  export type RateCreateNestedManyWithoutMaterialInput = {
    create?: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput> | RateCreateWithoutMaterialInput[] | RateUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RateCreateOrConnectWithoutMaterialInput | RateCreateOrConnectWithoutMaterialInput[]
    createMany?: RateCreateManyMaterialInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput> | ProductCreateWithoutMaterialInput[] | ProductUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMaterialInput | ProductCreateOrConnectWithoutMaterialInput[]
    createMany?: ProductCreateManyMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type RateUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput> | RateCreateWithoutMaterialInput[] | RateUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RateCreateOrConnectWithoutMaterialInput | RateCreateOrConnectWithoutMaterialInput[]
    createMany?: RateCreateManyMaterialInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput> | ProductCreateWithoutMaterialInput[] | ProductUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMaterialInput | ProductCreateOrConnectWithoutMaterialInput[]
    createMany?: ProductCreateManyMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ParishUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<ParishCreateWithoutMaterialsInput, ParishUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ParishCreateOrConnectWithoutMaterialsInput
    upsert?: ParishUpsertWithoutMaterialsInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutMaterialsInput, ParishUpdateWithoutMaterialsInput>, ParishUncheckedUpdateWithoutMaterialsInput>
  }

  export type UnitUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<UnitCreateWithoutMaterialsInput, UnitUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMaterialsInput
    upsert?: UnitUpsertWithoutMaterialsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutMaterialsInput, UnitUpdateWithoutMaterialsInput>, UnitUncheckedUpdateWithoutMaterialsInput>
  }

  export type RateUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput> | RateCreateWithoutMaterialInput[] | RateUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RateCreateOrConnectWithoutMaterialInput | RateCreateOrConnectWithoutMaterialInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutMaterialInput | RateUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: RateCreateManyMaterialInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutMaterialInput | RateUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: RateUpdateManyWithWhereWithoutMaterialInput | RateUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput> | ProductCreateWithoutMaterialInput[] | ProductUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMaterialInput | ProductCreateOrConnectWithoutMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutMaterialInput | ProductUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ProductCreateManyMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutMaterialInput | ProductUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutMaterialInput | ProductUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type RateUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput> | RateCreateWithoutMaterialInput[] | RateUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RateCreateOrConnectWithoutMaterialInput | RateCreateOrConnectWithoutMaterialInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutMaterialInput | RateUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: RateCreateManyMaterialInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutMaterialInput | RateUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: RateUpdateManyWithWhereWithoutMaterialInput | RateUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput> | ProductCreateWithoutMaterialInput[] | ProductUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutMaterialInput | ProductCreateOrConnectWithoutMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutMaterialInput | ProductUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ProductCreateManyMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutMaterialInput | ProductUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutMaterialInput | ProductUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MaterialCreateNestedManyWithoutUnitsInput = {
    create?: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput> | MaterialCreateWithoutUnitsInput[] | MaterialUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUnitsInput | MaterialCreateOrConnectWithoutUnitsInput[]
    createMany?: MaterialCreateManyUnitsInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RateCreateNestedManyWithoutUnitsInput = {
    create?: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput> | RateCreateWithoutUnitsInput[] | RateUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: RateCreateOrConnectWithoutUnitsInput | RateCreateOrConnectWithoutUnitsInput[]
    createMany?: RateCreateManyUnitsInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUnitsInput = {
    create?: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput> | ProductCreateWithoutUnitsInput[] | ProductUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitsInput | ProductCreateOrConnectWithoutUnitsInput[]
    createMany?: ProductCreateManyUnitsInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutUnitsInput = {
    create?: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput> | MaterialCreateWithoutUnitsInput[] | MaterialUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUnitsInput | MaterialCreateOrConnectWithoutUnitsInput[]
    createMany?: MaterialCreateManyUnitsInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RateUncheckedCreateNestedManyWithoutUnitsInput = {
    create?: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput> | RateCreateWithoutUnitsInput[] | RateUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: RateCreateOrConnectWithoutUnitsInput | RateCreateOrConnectWithoutUnitsInput[]
    createMany?: RateCreateManyUnitsInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUnitsInput = {
    create?: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput> | ProductCreateWithoutUnitsInput[] | ProductUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitsInput | ProductCreateOrConnectWithoutUnitsInput[]
    createMany?: ProductCreateManyUnitsInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MaterialUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput> | MaterialCreateWithoutUnitsInput[] | MaterialUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUnitsInput | MaterialCreateOrConnectWithoutUnitsInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutUnitsInput | MaterialUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: MaterialCreateManyUnitsInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutUnitsInput | MaterialUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutUnitsInput | MaterialUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RateUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput> | RateCreateWithoutUnitsInput[] | RateUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: RateCreateOrConnectWithoutUnitsInput | RateCreateOrConnectWithoutUnitsInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutUnitsInput | RateUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: RateCreateManyUnitsInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutUnitsInput | RateUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: RateUpdateManyWithWhereWithoutUnitsInput | RateUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput> | ProductCreateWithoutUnitsInput[] | ProductUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitsInput | ProductCreateOrConnectWithoutUnitsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitsInput | ProductUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: ProductCreateManyUnitsInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitsInput | ProductUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitsInput | ProductUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput> | MaterialCreateWithoutUnitsInput[] | MaterialUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUnitsInput | MaterialCreateOrConnectWithoutUnitsInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutUnitsInput | MaterialUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: MaterialCreateManyUnitsInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutUnitsInput | MaterialUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutUnitsInput | MaterialUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RateUncheckedUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput> | RateCreateWithoutUnitsInput[] | RateUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: RateCreateOrConnectWithoutUnitsInput | RateCreateOrConnectWithoutUnitsInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutUnitsInput | RateUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: RateCreateManyUnitsInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutUnitsInput | RateUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: RateUpdateManyWithWhereWithoutUnitsInput | RateUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput> | ProductCreateWithoutUnitsInput[] | ProductUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitsInput | ProductCreateOrConnectWithoutUnitsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitsInput | ProductUpsertWithWhereUniqueWithoutUnitsInput[]
    createMany?: ProductCreateManyUnitsInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitsInput | ProductUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitsInput | ProductUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ParishCreateNestedOneWithoutRateInput = {
    create?: XOR<ParishCreateWithoutRateInput, ParishUncheckedCreateWithoutRateInput>
    connectOrCreate?: ParishCreateOrConnectWithoutRateInput
    connect?: ParishWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutRatesInput = {
    create?: XOR<MaterialCreateWithoutRatesInput, MaterialUncheckedCreateWithoutRatesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRatesInput
    connect?: MaterialWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutRateInput = {
    create?: XOR<UnitCreateWithoutRateInput, UnitUncheckedCreateWithoutRateInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRateInput
    connect?: UnitWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutRatesInput = {
    create?: XOR<SupplierCreateWithoutRatesInput, SupplierUncheckedCreateWithoutRatesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutRatesInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutRateDetailsInput = {
    create?: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput> | ProductCreateWithoutRateDetailsInput[] | ProductUncheckedCreateWithoutRateDetailsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRateDetailsInput | ProductCreateOrConnectWithoutRateDetailsInput[]
    createMany?: ProductCreateManyRateDetailsInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutRateDetailsInput = {
    create?: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput> | ProductCreateWithoutRateDetailsInput[] | ProductUncheckedCreateWithoutRateDetailsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRateDetailsInput | ProductCreateOrConnectWithoutRateDetailsInput[]
    createMany?: ProductCreateManyRateDetailsInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParishUpdateOneRequiredWithoutRateNestedInput = {
    create?: XOR<ParishCreateWithoutRateInput, ParishUncheckedCreateWithoutRateInput>
    connectOrCreate?: ParishCreateOrConnectWithoutRateInput
    upsert?: ParishUpsertWithoutRateInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutRateInput, ParishUpdateWithoutRateInput>, ParishUncheckedUpdateWithoutRateInput>
  }

  export type MaterialUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<MaterialCreateWithoutRatesInput, MaterialUncheckedCreateWithoutRatesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRatesInput
    upsert?: MaterialUpsertWithoutRatesInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutRatesInput, MaterialUpdateWithoutRatesInput>, MaterialUncheckedUpdateWithoutRatesInput>
  }

  export type UnitUpdateOneRequiredWithoutRateNestedInput = {
    create?: XOR<UnitCreateWithoutRateInput, UnitUncheckedCreateWithoutRateInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRateInput
    upsert?: UnitUpsertWithoutRateInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutRateInput, UnitUpdateWithoutRateInput>, UnitUncheckedUpdateWithoutRateInput>
  }

  export type SupplierUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<SupplierCreateWithoutRatesInput, SupplierUncheckedCreateWithoutRatesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutRatesInput
    upsert?: SupplierUpsertWithoutRatesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutRatesInput, SupplierUpdateWithoutRatesInput>, SupplierUncheckedUpdateWithoutRatesInput>
  }

  export type ProductUpdateManyWithoutRateDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput> | ProductCreateWithoutRateDetailsInput[] | ProductUncheckedCreateWithoutRateDetailsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRateDetailsInput | ProductCreateOrConnectWithoutRateDetailsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutRateDetailsInput | ProductUpsertWithWhereUniqueWithoutRateDetailsInput[]
    createMany?: ProductCreateManyRateDetailsInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutRateDetailsInput | ProductUpdateWithWhereUniqueWithoutRateDetailsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutRateDetailsInput | ProductUpdateManyWithWhereWithoutRateDetailsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutRateDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput> | ProductCreateWithoutRateDetailsInput[] | ProductUncheckedCreateWithoutRateDetailsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRateDetailsInput | ProductCreateOrConnectWithoutRateDetailsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutRateDetailsInput | ProductUpsertWithWhereUniqueWithoutRateDetailsInput[]
    createMany?: ProductCreateManyRateDetailsInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutRateDetailsInput | ProductUpdateWithWhereUniqueWithoutRateDetailsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutRateDetailsInput | ProductUpdateManyWithWhereWithoutRateDetailsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ParishCreateNestedOneWithoutSupplierInput = {
    create?: XOR<ParishCreateWithoutSupplierInput, ParishUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: ParishCreateOrConnectWithoutSupplierInput
    connect?: ParishWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutSupplierInput = {
    create?: XOR<LocationCreateWithoutSupplierInput, LocationUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSupplierInput
    connect?: LocationWhereUniqueInput
  }

  export type RateCreateNestedManyWithoutSupplierInput = {
    create?: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput> | RateCreateWithoutSupplierInput[] | RateUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RateCreateOrConnectWithoutSupplierInput | RateCreateOrConnectWithoutSupplierInput[]
    createMany?: RateCreateManySupplierInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type RateUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput> | RateCreateWithoutSupplierInput[] | RateUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RateCreateOrConnectWithoutSupplierInput | RateCreateOrConnectWithoutSupplierInput[]
    createMany?: RateCreateManySupplierInputEnvelope
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ParishUpdateOneRequiredWithoutSupplierNestedInput = {
    create?: XOR<ParishCreateWithoutSupplierInput, ParishUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: ParishCreateOrConnectWithoutSupplierInput
    upsert?: ParishUpsertWithoutSupplierInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutSupplierInput, ParishUpdateWithoutSupplierInput>, ParishUncheckedUpdateWithoutSupplierInput>
  }

  export type LocationUpdateOneRequiredWithoutSupplierNestedInput = {
    create?: XOR<LocationCreateWithoutSupplierInput, LocationUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSupplierInput
    upsert?: LocationUpsertWithoutSupplierInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSupplierInput, LocationUpdateWithoutSupplierInput>, LocationUncheckedUpdateWithoutSupplierInput>
  }

  export type RateUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput> | RateCreateWithoutSupplierInput[] | RateUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RateCreateOrConnectWithoutSupplierInput | RateCreateOrConnectWithoutSupplierInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutSupplierInput | RateUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: RateCreateManySupplierInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutSupplierInput | RateUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: RateUpdateManyWithWhereWithoutSupplierInput | RateUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type RateUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput> | RateCreateWithoutSupplierInput[] | RateUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RateCreateOrConnectWithoutSupplierInput | RateCreateOrConnectWithoutSupplierInput[]
    upsert?: RateUpsertWithWhereUniqueWithoutSupplierInput | RateUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: RateCreateManySupplierInputEnvelope
    set?: RateWhereUniqueInput | RateWhereUniqueInput[]
    disconnect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    delete?: RateWhereUniqueInput | RateWhereUniqueInput[]
    connect?: RateWhereUniqueInput | RateWhereUniqueInput[]
    update?: RateUpdateWithWhereUniqueWithoutSupplierInput | RateUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: RateUpdateManyWithWhereWithoutSupplierInput | RateUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: RateScalarWhereInput | RateScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutProductInput = {
    create?: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductInput
    connect?: SupplierWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutProductInput = {
    create?: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductInput
    connect?: LocationWhereUniqueInput
  }

  export type ParishCreateNestedOneWithoutProductInput = {
    create?: XOR<ParishCreateWithoutProductInput, ParishUncheckedCreateWithoutProductInput>
    connectOrCreate?: ParishCreateOrConnectWithoutProductInput
    connect?: ParishWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutProductInput = {
    create?: XOR<MaterialCreateWithoutProductInput, MaterialUncheckedCreateWithoutProductInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductInput
    connect?: MaterialWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutProductInput = {
    create?: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductInput
    connect?: UnitWhereUniqueInput
  }

  export type RateCreateNestedOneWithoutProductInput = {
    create?: XOR<RateCreateWithoutProductInput, RateUncheckedCreateWithoutProductInput>
    connectOrCreate?: RateCreateOrConnectWithoutProductInput
    connect?: RateWhereUniqueInput
  }

  export type SupplierUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductInput
    upsert?: SupplierUpsertWithoutProductInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutProductInput, SupplierUpdateWithoutProductInput>, SupplierUncheckedUpdateWithoutProductInput>
  }

  export type LocationUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductInput
    upsert?: LocationUpsertWithoutProductInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProductInput, LocationUpdateWithoutProductInput>, LocationUncheckedUpdateWithoutProductInput>
  }

  export type ParishUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<ParishCreateWithoutProductInput, ParishUncheckedCreateWithoutProductInput>
    connectOrCreate?: ParishCreateOrConnectWithoutProductInput
    upsert?: ParishUpsertWithoutProductInput
    connect?: ParishWhereUniqueInput
    update?: XOR<XOR<ParishUpdateToOneWithWhereWithoutProductInput, ParishUpdateWithoutProductInput>, ParishUncheckedUpdateWithoutProductInput>
  }

  export type MaterialUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<MaterialCreateWithoutProductInput, MaterialUncheckedCreateWithoutProductInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductInput
    upsert?: MaterialUpsertWithoutProductInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutProductInput, MaterialUpdateWithoutProductInput>, MaterialUncheckedUpdateWithoutProductInput>
  }

  export type UnitUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductInput
    upsert?: UnitUpsertWithoutProductInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutProductInput, UnitUpdateWithoutProductInput>, UnitUncheckedUpdateWithoutProductInput>
  }

  export type RateUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<RateCreateWithoutProductInput, RateUncheckedCreateWithoutProductInput>
    connectOrCreate?: RateCreateOrConnectWithoutProductInput
    upsert?: RateUpsertWithoutProductInput
    connect?: RateWhereUniqueInput
    update?: XOR<XOR<RateUpdateToOneWithWhereWithoutProductInput, RateUpdateWithoutProductInput>, RateUncheckedUpdateWithoutProductInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LocationCreateWithoutUserInput = {
    locationName: string
    region: RegionCreateNestedOneWithoutLocationsInput
    parishes?: ParishCreateNestedManyWithoutLocationInput
    Product?: ProductCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateWithoutUserInput = {
    id?: number
    locationName: string
    regionId: number
    parishes?: ParishUncheckedCreateNestedManyWithoutLocationInput
    Product?: ProductUncheckedCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationCreateOrConnectWithoutUserInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
  }

  export type LocationUpsertWithoutUserInput = {
    update: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUserInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
  }

  export type LocationUpdateWithoutUserInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    parishes?: ParishUpdateManyWithoutLocationNestedInput
    Product?: ProductUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
    parishes?: ParishUncheckedUpdateManyWithoutLocationNestedInput
    Product?: ProductUncheckedUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationCreateWithoutRegionInput = {
    locationName: string
    parishes?: ParishCreateNestedManyWithoutLocationInput
    User?: UserCreateNestedManyWithoutLocationInput
    Product?: ProductCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateWithoutRegionInput = {
    id?: number
    locationName: string
    parishes?: ParishUncheckedCreateNestedManyWithoutLocationInput
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
    Product?: ProductUncheckedCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationCreateOrConnectWithoutRegionInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput>
  }

  export type LocationCreateManyRegionInputEnvelope = {
    data: LocationCreateManyRegionInput | LocationCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutRegionInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutRegionInput, LocationUncheckedUpdateWithoutRegionInput>
    create: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutRegionInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutRegionInput, LocationUncheckedUpdateWithoutRegionInput>
  }

  export type LocationUpdateManyWithWhereWithoutRegionInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutRegionInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: IntFilter<"Location"> | number
    locationName?: StringFilter<"Location"> | string
    regionId?: IntFilter<"Location"> | number
  }

  export type RegionCreateWithoutLocationsInput = {
    regionName: string
  }

  export type RegionUncheckedCreateWithoutLocationsInput = {
    id?: number
    regionName: string
  }

  export type RegionCreateOrConnectWithoutLocationsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
  }

  export type ParishCreateWithoutLocationInput = {
    parishName: string
    materials?: MaterialCreateNestedManyWithoutParishInput
    Rate?: RateCreateNestedManyWithoutParishInput
    Supplier?: SupplierCreateNestedManyWithoutParishInput
    Product?: ProductCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutLocationInput = {
    id?: number
    parishName: string
    materials?: MaterialUncheckedCreateNestedManyWithoutParishInput
    Rate?: RateUncheckedCreateNestedManyWithoutParishInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutParishInput
    Product?: ProductUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutLocationInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput>
  }

  export type ParishCreateManyLocationInputEnvelope = {
    data: ParishCreateManyLocationInput | ParishCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLocationInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserCreateManyLocationInputEnvelope = {
    data: UserCreateManyLocationInput | UserCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutLocationNameInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutLocationNameInput = {
    id?: number
    rateId: number
    supplierId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductCreateOrConnectWithoutLocationNameInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput>
  }

  export type ProductCreateManyLocationNameInputEnvelope = {
    data: ProductCreateManyLocationNameInput | ProductCreateManyLocationNameInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutLocationNameInput = {
    supplierName: string
    parish: ParishCreateNestedOneWithoutSupplierInput
    rates?: RateCreateNestedManyWithoutSupplierInput
    Product?: ProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutLocationNameInput = {
    id?: number
    supplierName: string
    parishId: number
    rates?: RateUncheckedCreateNestedManyWithoutSupplierInput
    Product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutLocationNameInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput>
  }

  export type SupplierCreateManyLocationNameInputEnvelope = {
    data: SupplierCreateManyLocationNameInput | SupplierCreateManyLocationNameInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutLocationsInput = {
    update: XOR<RegionUpdateWithoutLocationsInput, RegionUncheckedUpdateWithoutLocationsInput>
    create: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutLocationsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutLocationsInput, RegionUncheckedUpdateWithoutLocationsInput>
  }

  export type RegionUpdateWithoutLocationsInput = {
    regionName?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
  }

  export type ParishUpsertWithWhereUniqueWithoutLocationInput = {
    where: ParishWhereUniqueInput
    update: XOR<ParishUpdateWithoutLocationInput, ParishUncheckedUpdateWithoutLocationInput>
    create: XOR<ParishCreateWithoutLocationInput, ParishUncheckedCreateWithoutLocationInput>
  }

  export type ParishUpdateWithWhereUniqueWithoutLocationInput = {
    where: ParishWhereUniqueInput
    data: XOR<ParishUpdateWithoutLocationInput, ParishUncheckedUpdateWithoutLocationInput>
  }

  export type ParishUpdateManyWithWhereWithoutLocationInput = {
    where: ParishScalarWhereInput
    data: XOR<ParishUpdateManyMutationInput, ParishUncheckedUpdateManyWithoutLocationInput>
  }

  export type ParishScalarWhereInput = {
    AND?: ParishScalarWhereInput | ParishScalarWhereInput[]
    OR?: ParishScalarWhereInput[]
    NOT?: ParishScalarWhereInput | ParishScalarWhereInput[]
    id?: IntFilter<"Parish"> | number
    parishName?: StringFilter<"Parish"> | string
    locationId?: IntFilter<"Parish"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    locationId?: IntNullableFilter<"User"> | number | null
  }

  export type ProductUpsertWithWhereUniqueWithoutLocationNameInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutLocationNameInput, ProductUncheckedUpdateWithoutLocationNameInput>
    create: XOR<ProductCreateWithoutLocationNameInput, ProductUncheckedCreateWithoutLocationNameInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutLocationNameInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutLocationNameInput, ProductUncheckedUpdateWithoutLocationNameInput>
  }

  export type ProductUpdateManyWithWhereWithoutLocationNameInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutLocationNameInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    rateId?: IntFilter<"Product"> | number
    supplierId?: IntFilter<"Product"> | number
    locationId?: IntFilter<"Product"> | number
    parishId?: IntFilter<"Product"> | number
    materialId?: IntFilter<"Product"> | number
    unitsId?: IntFilter<"Product"> | number
  }

  export type SupplierUpsertWithWhereUniqueWithoutLocationNameInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutLocationNameInput, SupplierUncheckedUpdateWithoutLocationNameInput>
    create: XOR<SupplierCreateWithoutLocationNameInput, SupplierUncheckedCreateWithoutLocationNameInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutLocationNameInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutLocationNameInput, SupplierUncheckedUpdateWithoutLocationNameInput>
  }

  export type SupplierUpdateManyWithWhereWithoutLocationNameInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutLocationNameInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: IntFilter<"Supplier"> | number
    supplierName?: StringFilter<"Supplier"> | string
    parishId?: IntFilter<"Supplier"> | number
    locationId?: IntFilter<"Supplier"> | number
  }

  export type LocationCreateWithoutParishesInput = {
    locationName: string
    region: RegionCreateNestedOneWithoutLocationsInput
    User?: UserCreateNestedManyWithoutLocationInput
    Product?: ProductCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateWithoutParishesInput = {
    id?: number
    locationName: string
    regionId: number
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
    Product?: ProductUncheckedCreateNestedManyWithoutLocationNameInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationCreateOrConnectWithoutParishesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutParishesInput, LocationUncheckedCreateWithoutParishesInput>
  }

  export type MaterialCreateWithoutParishInput = {
    materialName: string
    units: UnitCreateNestedOneWithoutMaterialsInput
    rates?: RateCreateNestedManyWithoutMaterialInput
    Product?: ProductCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutParishInput = {
    id?: number
    materialName: string
    unitsId: number
    rates?: RateUncheckedCreateNestedManyWithoutMaterialInput
    Product?: ProductUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutParishInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput>
  }

  export type MaterialCreateManyParishInputEnvelope = {
    data: MaterialCreateManyParishInput | MaterialCreateManyParishInput[]
    skipDuplicates?: boolean
  }

  export type RateCreateWithoutParishInput = {
    rateValue: number
    material: MaterialCreateNestedOneWithoutRatesInput
    units: UnitCreateNestedOneWithoutRateInput
    supplier: SupplierCreateNestedOneWithoutRatesInput
    Product?: ProductCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUncheckedCreateWithoutParishInput = {
    id?: number
    rateValue: number
    materialId: number
    unitsId: number
    supplierId: number
    Product?: ProductUncheckedCreateNestedManyWithoutRateDetailsInput
  }

  export type RateCreateOrConnectWithoutParishInput = {
    where: RateWhereUniqueInput
    create: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput>
  }

  export type RateCreateManyParishInputEnvelope = {
    data: RateCreateManyParishInput | RateCreateManyParishInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutParishInput = {
    supplierName: string
    locationName: LocationCreateNestedOneWithoutSupplierInput
    rates?: RateCreateNestedManyWithoutSupplierInput
    Product?: ProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutParishInput = {
    id?: number
    supplierName: string
    locationId: number
    rates?: RateUncheckedCreateNestedManyWithoutSupplierInput
    Product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutParishInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput>
  }

  export type SupplierCreateManyParishInputEnvelope = {
    data: SupplierCreateManyParishInput | SupplierCreateManyParishInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutParishInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    locationName: LocationCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutParishInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    materialId: number
    unitsId: number
  }

  export type ProductCreateOrConnectWithoutParishInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput>
  }

  export type ProductCreateManyParishInputEnvelope = {
    data: ProductCreateManyParishInput | ProductCreateManyParishInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutParishesInput = {
    update: XOR<LocationUpdateWithoutParishesInput, LocationUncheckedUpdateWithoutParishesInput>
    create: XOR<LocationCreateWithoutParishesInput, LocationUncheckedCreateWithoutParishesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutParishesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutParishesInput, LocationUncheckedUpdateWithoutParishesInput>
  }

  export type LocationUpdateWithoutParishesInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
    Product?: ProductUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateWithoutParishesInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
    Product?: ProductUncheckedUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type MaterialUpsertWithWhereUniqueWithoutParishInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutParishInput, MaterialUncheckedUpdateWithoutParishInput>
    create: XOR<MaterialCreateWithoutParishInput, MaterialUncheckedCreateWithoutParishInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutParishInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutParishInput, MaterialUncheckedUpdateWithoutParishInput>
  }

  export type MaterialUpdateManyWithWhereWithoutParishInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutParishInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: IntFilter<"Material"> | number
    materialName?: StringFilter<"Material"> | string
    parishId?: IntFilter<"Material"> | number
    unitsId?: IntFilter<"Material"> | number
  }

  export type RateUpsertWithWhereUniqueWithoutParishInput = {
    where: RateWhereUniqueInput
    update: XOR<RateUpdateWithoutParishInput, RateUncheckedUpdateWithoutParishInput>
    create: XOR<RateCreateWithoutParishInput, RateUncheckedCreateWithoutParishInput>
  }

  export type RateUpdateWithWhereUniqueWithoutParishInput = {
    where: RateWhereUniqueInput
    data: XOR<RateUpdateWithoutParishInput, RateUncheckedUpdateWithoutParishInput>
  }

  export type RateUpdateManyWithWhereWithoutParishInput = {
    where: RateScalarWhereInput
    data: XOR<RateUpdateManyMutationInput, RateUncheckedUpdateManyWithoutParishInput>
  }

  export type RateScalarWhereInput = {
    AND?: RateScalarWhereInput | RateScalarWhereInput[]
    OR?: RateScalarWhereInput[]
    NOT?: RateScalarWhereInput | RateScalarWhereInput[]
    id?: IntFilter<"Rate"> | number
    rateValue?: FloatFilter<"Rate"> | number
    parishId?: IntFilter<"Rate"> | number
    materialId?: IntFilter<"Rate"> | number
    unitsId?: IntFilter<"Rate"> | number
    supplierId?: IntFilter<"Rate"> | number
  }

  export type SupplierUpsertWithWhereUniqueWithoutParishInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutParishInput, SupplierUncheckedUpdateWithoutParishInput>
    create: XOR<SupplierCreateWithoutParishInput, SupplierUncheckedCreateWithoutParishInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutParishInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutParishInput, SupplierUncheckedUpdateWithoutParishInput>
  }

  export type SupplierUpdateManyWithWhereWithoutParishInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutParishInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutParishInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutParishInput, ProductUncheckedUpdateWithoutParishInput>
    create: XOR<ProductCreateWithoutParishInput, ProductUncheckedCreateWithoutParishInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutParishInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutParishInput, ProductUncheckedUpdateWithoutParishInput>
  }

  export type ProductUpdateManyWithWhereWithoutParishInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutParishInput>
  }

  export type ParishCreateWithoutMaterialsInput = {
    parishName: string
    location: LocationCreateNestedOneWithoutParishesInput
    Rate?: RateCreateNestedManyWithoutParishInput
    Supplier?: SupplierCreateNestedManyWithoutParishInput
    Product?: ProductCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutMaterialsInput = {
    id?: number
    parishName: string
    locationId: number
    Rate?: RateUncheckedCreateNestedManyWithoutParishInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutParishInput
    Product?: ProductUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutMaterialsInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutMaterialsInput, ParishUncheckedCreateWithoutMaterialsInput>
  }

  export type UnitCreateWithoutMaterialsInput = {
    unitName: string
    Rate?: RateCreateNestedManyWithoutUnitsInput
    Product?: ProductCreateNestedManyWithoutUnitsInput
  }

  export type UnitUncheckedCreateWithoutMaterialsInput = {
    id?: number
    unitName: string
    Rate?: RateUncheckedCreateNestedManyWithoutUnitsInput
    Product?: ProductUncheckedCreateNestedManyWithoutUnitsInput
  }

  export type UnitCreateOrConnectWithoutMaterialsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutMaterialsInput, UnitUncheckedCreateWithoutMaterialsInput>
  }

  export type RateCreateWithoutMaterialInput = {
    rateValue: number
    parish: ParishCreateNestedOneWithoutRateInput
    units: UnitCreateNestedOneWithoutRateInput
    supplier: SupplierCreateNestedOneWithoutRatesInput
    Product?: ProductCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUncheckedCreateWithoutMaterialInput = {
    id?: number
    rateValue: number
    parishId: number
    unitsId: number
    supplierId: number
    Product?: ProductUncheckedCreateNestedManyWithoutRateDetailsInput
  }

  export type RateCreateOrConnectWithoutMaterialInput = {
    where: RateWhereUniqueInput
    create: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput>
  }

  export type RateCreateManyMaterialInputEnvelope = {
    data: RateCreateManyMaterialInput | RateCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutMaterialInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    locationName: LocationCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMaterialInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    unitsId: number
  }

  export type ProductCreateOrConnectWithoutMaterialInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput>
  }

  export type ProductCreateManyMaterialInputEnvelope = {
    data: ProductCreateManyMaterialInput | ProductCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ParishUpsertWithoutMaterialsInput = {
    update: XOR<ParishUpdateWithoutMaterialsInput, ParishUncheckedUpdateWithoutMaterialsInput>
    create: XOR<ParishCreateWithoutMaterialsInput, ParishUncheckedCreateWithoutMaterialsInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutMaterialsInput, ParishUncheckedUpdateWithoutMaterialsInput>
  }

  export type ParishUpdateWithoutMaterialsInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutParishesNestedInput
    Rate?: RateUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUpdateManyWithoutParishNestedInput
    Product?: ProductUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    Rate?: RateUncheckedUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutParishNestedInput
    Product?: ProductUncheckedUpdateManyWithoutParishNestedInput
  }

  export type UnitUpsertWithoutMaterialsInput = {
    update: XOR<UnitUpdateWithoutMaterialsInput, UnitUncheckedUpdateWithoutMaterialsInput>
    create: XOR<UnitCreateWithoutMaterialsInput, UnitUncheckedCreateWithoutMaterialsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutMaterialsInput, UnitUncheckedUpdateWithoutMaterialsInput>
  }

  export type UnitUpdateWithoutMaterialsInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    Rate?: RateUpdateManyWithoutUnitsNestedInput
    Product?: ProductUpdateManyWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    Rate?: RateUncheckedUpdateManyWithoutUnitsNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUnitsNestedInput
  }

  export type RateUpsertWithWhereUniqueWithoutMaterialInput = {
    where: RateWhereUniqueInput
    update: XOR<RateUpdateWithoutMaterialInput, RateUncheckedUpdateWithoutMaterialInput>
    create: XOR<RateCreateWithoutMaterialInput, RateUncheckedCreateWithoutMaterialInput>
  }

  export type RateUpdateWithWhereUniqueWithoutMaterialInput = {
    where: RateWhereUniqueInput
    data: XOR<RateUpdateWithoutMaterialInput, RateUncheckedUpdateWithoutMaterialInput>
  }

  export type RateUpdateManyWithWhereWithoutMaterialInput = {
    where: RateScalarWhereInput
    data: XOR<RateUpdateManyMutationInput, RateUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutMaterialInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutMaterialInput, ProductUncheckedUpdateWithoutMaterialInput>
    create: XOR<ProductCreateWithoutMaterialInput, ProductUncheckedCreateWithoutMaterialInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutMaterialInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutMaterialInput, ProductUncheckedUpdateWithoutMaterialInput>
  }

  export type ProductUpdateManyWithWhereWithoutMaterialInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutMaterialInput>
  }

  export type MaterialCreateWithoutUnitsInput = {
    materialName: string
    parish: ParishCreateNestedOneWithoutMaterialsInput
    rates?: RateCreateNestedManyWithoutMaterialInput
    Product?: ProductCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutUnitsInput = {
    id?: number
    materialName: string
    parishId: number
    rates?: RateUncheckedCreateNestedManyWithoutMaterialInput
    Product?: ProductUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutUnitsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput>
  }

  export type MaterialCreateManyUnitsInputEnvelope = {
    data: MaterialCreateManyUnitsInput | MaterialCreateManyUnitsInput[]
    skipDuplicates?: boolean
  }

  export type RateCreateWithoutUnitsInput = {
    rateValue: number
    parish: ParishCreateNestedOneWithoutRateInput
    material: MaterialCreateNestedOneWithoutRatesInput
    supplier: SupplierCreateNestedOneWithoutRatesInput
    Product?: ProductCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUncheckedCreateWithoutUnitsInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    supplierId: number
    Product?: ProductUncheckedCreateNestedManyWithoutRateDetailsInput
  }

  export type RateCreateOrConnectWithoutUnitsInput = {
    where: RateWhereUniqueInput
    create: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput>
  }

  export type RateCreateManyUnitsInputEnvelope = {
    data: RateCreateManyUnitsInput | RateCreateManyUnitsInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUnitsInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    locationName: LocationCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUnitsInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
  }

  export type ProductCreateOrConnectWithoutUnitsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput>
  }

  export type ProductCreateManyUnitsInputEnvelope = {
    data: ProductCreateManyUnitsInput | ProductCreateManyUnitsInput[]
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithWhereUniqueWithoutUnitsInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutUnitsInput, MaterialUncheckedUpdateWithoutUnitsInput>
    create: XOR<MaterialCreateWithoutUnitsInput, MaterialUncheckedCreateWithoutUnitsInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutUnitsInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutUnitsInput, MaterialUncheckedUpdateWithoutUnitsInput>
  }

  export type MaterialUpdateManyWithWhereWithoutUnitsInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutUnitsInput>
  }

  export type RateUpsertWithWhereUniqueWithoutUnitsInput = {
    where: RateWhereUniqueInput
    update: XOR<RateUpdateWithoutUnitsInput, RateUncheckedUpdateWithoutUnitsInput>
    create: XOR<RateCreateWithoutUnitsInput, RateUncheckedCreateWithoutUnitsInput>
  }

  export type RateUpdateWithWhereUniqueWithoutUnitsInput = {
    where: RateWhereUniqueInput
    data: XOR<RateUpdateWithoutUnitsInput, RateUncheckedUpdateWithoutUnitsInput>
  }

  export type RateUpdateManyWithWhereWithoutUnitsInput = {
    where: RateScalarWhereInput
    data: XOR<RateUpdateManyMutationInput, RateUncheckedUpdateManyWithoutUnitsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutUnitsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUnitsInput, ProductUncheckedUpdateWithoutUnitsInput>
    create: XOR<ProductCreateWithoutUnitsInput, ProductUncheckedCreateWithoutUnitsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUnitsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUnitsInput, ProductUncheckedUpdateWithoutUnitsInput>
  }

  export type ProductUpdateManyWithWhereWithoutUnitsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUnitsInput>
  }

  export type ParishCreateWithoutRateInput = {
    parishName: string
    location: LocationCreateNestedOneWithoutParishesInput
    materials?: MaterialCreateNestedManyWithoutParishInput
    Supplier?: SupplierCreateNestedManyWithoutParishInput
    Product?: ProductCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutRateInput = {
    id?: number
    parishName: string
    locationId: number
    materials?: MaterialUncheckedCreateNestedManyWithoutParishInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutParishInput
    Product?: ProductUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutRateInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutRateInput, ParishUncheckedCreateWithoutRateInput>
  }

  export type MaterialCreateWithoutRatesInput = {
    materialName: string
    parish: ParishCreateNestedOneWithoutMaterialsInput
    units: UnitCreateNestedOneWithoutMaterialsInput
    Product?: ProductCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutRatesInput = {
    id?: number
    materialName: string
    parishId: number
    unitsId: number
    Product?: ProductUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutRatesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutRatesInput, MaterialUncheckedCreateWithoutRatesInput>
  }

  export type UnitCreateWithoutRateInput = {
    unitName: string
    materials?: MaterialCreateNestedManyWithoutUnitsInput
    Product?: ProductCreateNestedManyWithoutUnitsInput
  }

  export type UnitUncheckedCreateWithoutRateInput = {
    id?: number
    unitName: string
    materials?: MaterialUncheckedCreateNestedManyWithoutUnitsInput
    Product?: ProductUncheckedCreateNestedManyWithoutUnitsInput
  }

  export type UnitCreateOrConnectWithoutRateInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutRateInput, UnitUncheckedCreateWithoutRateInput>
  }

  export type SupplierCreateWithoutRatesInput = {
    supplierName: string
    parish: ParishCreateNestedOneWithoutSupplierInput
    locationName: LocationCreateNestedOneWithoutSupplierInput
    Product?: ProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutRatesInput = {
    id?: number
    supplierName: string
    parishId: number
    locationId: number
    Product?: ProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutRatesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutRatesInput, SupplierUncheckedCreateWithoutRatesInput>
  }

  export type ProductCreateWithoutRateDetailsInput = {
    supplier: SupplierCreateNestedOneWithoutProductInput
    locationName: LocationCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRateDetailsInput = {
    id?: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductCreateOrConnectWithoutRateDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput>
  }

  export type ProductCreateManyRateDetailsInputEnvelope = {
    data: ProductCreateManyRateDetailsInput | ProductCreateManyRateDetailsInput[]
    skipDuplicates?: boolean
  }

  export type ParishUpsertWithoutRateInput = {
    update: XOR<ParishUpdateWithoutRateInput, ParishUncheckedUpdateWithoutRateInput>
    create: XOR<ParishCreateWithoutRateInput, ParishUncheckedCreateWithoutRateInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutRateInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutRateInput, ParishUncheckedUpdateWithoutRateInput>
  }

  export type ParishUpdateWithoutRateInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutParishesNestedInput
    materials?: MaterialUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUpdateManyWithoutParishNestedInput
    Product?: ProductUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUncheckedUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutParishNestedInput
    Product?: ProductUncheckedUpdateManyWithoutParishNestedInput
  }

  export type MaterialUpsertWithoutRatesInput = {
    update: XOR<MaterialUpdateWithoutRatesInput, MaterialUncheckedUpdateWithoutRatesInput>
    create: XOR<MaterialCreateWithoutRatesInput, MaterialUncheckedCreateWithoutRatesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutRatesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutRatesInput, MaterialUncheckedUpdateWithoutRatesInput>
  }

  export type MaterialUpdateWithoutRatesInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutMaterialsNestedInput
    units?: UnitUpdateOneRequiredWithoutMaterialsNestedInput
    Product?: ProductUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type UnitUpsertWithoutRateInput = {
    update: XOR<UnitUpdateWithoutRateInput, UnitUncheckedUpdateWithoutRateInput>
    create: XOR<UnitCreateWithoutRateInput, UnitUncheckedCreateWithoutRateInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutRateInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutRateInput, UnitUncheckedUpdateWithoutRateInput>
  }

  export type UnitUpdateWithoutRateInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUpdateManyWithoutUnitsNestedInput
    Product?: ProductUpdateManyWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateWithoutRateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutUnitsNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUnitsNestedInput
  }

  export type SupplierUpsertWithoutRatesInput = {
    update: XOR<SupplierUpdateWithoutRatesInput, SupplierUncheckedUpdateWithoutRatesInput>
    create: XOR<SupplierCreateWithoutRatesInput, SupplierUncheckedCreateWithoutRatesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutRatesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutRatesInput, SupplierUncheckedUpdateWithoutRatesInput>
  }

  export type SupplierUpdateWithoutRatesInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutSupplierNestedInput
    locationName?: LocationUpdateOneRequiredWithoutSupplierNestedInput
    Product?: ProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutRateDetailsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutRateDetailsInput, ProductUncheckedUpdateWithoutRateDetailsInput>
    create: XOR<ProductCreateWithoutRateDetailsInput, ProductUncheckedCreateWithoutRateDetailsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutRateDetailsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutRateDetailsInput, ProductUncheckedUpdateWithoutRateDetailsInput>
  }

  export type ProductUpdateManyWithWhereWithoutRateDetailsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutRateDetailsInput>
  }

  export type ParishCreateWithoutSupplierInput = {
    parishName: string
    location: LocationCreateNestedOneWithoutParishesInput
    materials?: MaterialCreateNestedManyWithoutParishInput
    Rate?: RateCreateNestedManyWithoutParishInput
    Product?: ProductCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutSupplierInput = {
    id?: number
    parishName: string
    locationId: number
    materials?: MaterialUncheckedCreateNestedManyWithoutParishInput
    Rate?: RateUncheckedCreateNestedManyWithoutParishInput
    Product?: ProductUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutSupplierInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutSupplierInput, ParishUncheckedCreateWithoutSupplierInput>
  }

  export type LocationCreateWithoutSupplierInput = {
    locationName: string
    region: RegionCreateNestedOneWithoutLocationsInput
    parishes?: ParishCreateNestedManyWithoutLocationInput
    User?: UserCreateNestedManyWithoutLocationInput
    Product?: ProductCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateWithoutSupplierInput = {
    id?: number
    locationName: string
    regionId: number
    parishes?: ParishUncheckedCreateNestedManyWithoutLocationInput
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
    Product?: ProductUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationCreateOrConnectWithoutSupplierInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSupplierInput, LocationUncheckedCreateWithoutSupplierInput>
  }

  export type RateCreateWithoutSupplierInput = {
    rateValue: number
    parish: ParishCreateNestedOneWithoutRateInput
    material: MaterialCreateNestedOneWithoutRatesInput
    units: UnitCreateNestedOneWithoutRateInput
    Product?: ProductCreateNestedManyWithoutRateDetailsInput
  }

  export type RateUncheckedCreateWithoutSupplierInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    Product?: ProductUncheckedCreateNestedManyWithoutRateDetailsInput
  }

  export type RateCreateOrConnectWithoutSupplierInput = {
    where: RateWhereUniqueInput
    create: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput>
  }

  export type RateCreateManySupplierInputEnvelope = {
    data: RateCreateManySupplierInput | RateCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSupplierInput = {
    locationName: LocationCreateNestedOneWithoutProductInput
    parish: ParishCreateNestedOneWithoutProductInput
    material: MaterialCreateNestedOneWithoutProductInput
    units: UnitCreateNestedOneWithoutProductInput
    rateDetails: RateCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierInput = {
    id?: number
    rateId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductCreateOrConnectWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductCreateManySupplierInputEnvelope = {
    data: ProductCreateManySupplierInput | ProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ParishUpsertWithoutSupplierInput = {
    update: XOR<ParishUpdateWithoutSupplierInput, ParishUncheckedUpdateWithoutSupplierInput>
    create: XOR<ParishCreateWithoutSupplierInput, ParishUncheckedCreateWithoutSupplierInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutSupplierInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutSupplierInput, ParishUncheckedUpdateWithoutSupplierInput>
  }

  export type ParishUpdateWithoutSupplierInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutParishesNestedInput
    materials?: MaterialUpdateManyWithoutParishNestedInput
    Rate?: RateUpdateManyWithoutParishNestedInput
    Product?: ProductUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUncheckedUpdateManyWithoutParishNestedInput
    Rate?: RateUncheckedUpdateManyWithoutParishNestedInput
    Product?: ProductUncheckedUpdateManyWithoutParishNestedInput
  }

  export type LocationUpsertWithoutSupplierInput = {
    update: XOR<LocationUpdateWithoutSupplierInput, LocationUncheckedUpdateWithoutSupplierInput>
    create: XOR<LocationCreateWithoutSupplierInput, LocationUncheckedCreateWithoutSupplierInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSupplierInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSupplierInput, LocationUncheckedUpdateWithoutSupplierInput>
  }

  export type LocationUpdateWithoutSupplierInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    parishes?: ParishUpdateManyWithoutLocationNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
    Product?: ProductUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
    parishes?: ParishUncheckedUpdateManyWithoutLocationNestedInput
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
    Product?: ProductUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type RateUpsertWithWhereUniqueWithoutSupplierInput = {
    where: RateWhereUniqueInput
    update: XOR<RateUpdateWithoutSupplierInput, RateUncheckedUpdateWithoutSupplierInput>
    create: XOR<RateCreateWithoutSupplierInput, RateUncheckedCreateWithoutSupplierInput>
  }

  export type RateUpdateWithWhereUniqueWithoutSupplierInput = {
    where: RateWhereUniqueInput
    data: XOR<RateUpdateWithoutSupplierInput, RateUncheckedUpdateWithoutSupplierInput>
  }

  export type RateUpdateManyWithWhereWithoutSupplierInput = {
    where: RateScalarWhereInput
    data: XOR<RateUpdateManyMutationInput, RateUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierCreateWithoutProductInput = {
    supplierName: string
    parish: ParishCreateNestedOneWithoutSupplierInput
    locationName: LocationCreateNestedOneWithoutSupplierInput
    rates?: RateCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductInput = {
    id?: number
    supplierName: string
    parishId: number
    locationId: number
    rates?: RateUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
  }

  export type LocationCreateWithoutProductInput = {
    locationName: string
    region: RegionCreateNestedOneWithoutLocationsInput
    parishes?: ParishCreateNestedManyWithoutLocationInput
    User?: UserCreateNestedManyWithoutLocationInput
    Supplier?: SupplierCreateNestedManyWithoutLocationNameInput
  }

  export type LocationUncheckedCreateWithoutProductInput = {
    id?: number
    locationName: string
    regionId: number
    parishes?: ParishUncheckedCreateNestedManyWithoutLocationInput
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutLocationNameInput
  }

  export type LocationCreateOrConnectWithoutProductInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
  }

  export type ParishCreateWithoutProductInput = {
    parishName: string
    location: LocationCreateNestedOneWithoutParishesInput
    materials?: MaterialCreateNestedManyWithoutParishInput
    Rate?: RateCreateNestedManyWithoutParishInput
    Supplier?: SupplierCreateNestedManyWithoutParishInput
  }

  export type ParishUncheckedCreateWithoutProductInput = {
    id?: number
    parishName: string
    locationId: number
    materials?: MaterialUncheckedCreateNestedManyWithoutParishInput
    Rate?: RateUncheckedCreateNestedManyWithoutParishInput
    Supplier?: SupplierUncheckedCreateNestedManyWithoutParishInput
  }

  export type ParishCreateOrConnectWithoutProductInput = {
    where: ParishWhereUniqueInput
    create: XOR<ParishCreateWithoutProductInput, ParishUncheckedCreateWithoutProductInput>
  }

  export type MaterialCreateWithoutProductInput = {
    materialName: string
    parish: ParishCreateNestedOneWithoutMaterialsInput
    units: UnitCreateNestedOneWithoutMaterialsInput
    rates?: RateCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutProductInput = {
    id?: number
    materialName: string
    parishId: number
    unitsId: number
    rates?: RateUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutProductInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutProductInput, MaterialUncheckedCreateWithoutProductInput>
  }

  export type UnitCreateWithoutProductInput = {
    unitName: string
    materials?: MaterialCreateNestedManyWithoutUnitsInput
    Rate?: RateCreateNestedManyWithoutUnitsInput
  }

  export type UnitUncheckedCreateWithoutProductInput = {
    id?: number
    unitName: string
    materials?: MaterialUncheckedCreateNestedManyWithoutUnitsInput
    Rate?: RateUncheckedCreateNestedManyWithoutUnitsInput
  }

  export type UnitCreateOrConnectWithoutProductInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
  }

  export type RateCreateWithoutProductInput = {
    rateValue: number
    parish: ParishCreateNestedOneWithoutRateInput
    material: MaterialCreateNestedOneWithoutRatesInput
    units: UnitCreateNestedOneWithoutRateInput
    supplier: SupplierCreateNestedOneWithoutRatesInput
  }

  export type RateUncheckedCreateWithoutProductInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
    supplierId: number
  }

  export type RateCreateOrConnectWithoutProductInput = {
    where: RateWhereUniqueInput
    create: XOR<RateCreateWithoutProductInput, RateUncheckedCreateWithoutProductInput>
  }

  export type SupplierUpsertWithoutProductInput = {
    update: XOR<SupplierUpdateWithoutProductInput, SupplierUncheckedUpdateWithoutProductInput>
    create: XOR<SupplierCreateWithoutProductInput, SupplierUncheckedCreateWithoutProductInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutProductInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutProductInput, SupplierUncheckedUpdateWithoutProductInput>
  }

  export type SupplierUpdateWithoutProductInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutSupplierNestedInput
    locationName?: LocationUpdateOneRequiredWithoutSupplierNestedInput
    rates?: RateUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type LocationUpsertWithoutProductInput = {
    update: XOR<LocationUpdateWithoutProductInput, LocationUncheckedUpdateWithoutProductInput>
    create: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProductInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProductInput, LocationUncheckedUpdateWithoutProductInput>
  }

  export type LocationUpdateWithoutProductInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    parishes?: ParishUpdateManyWithoutLocationNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
    Supplier?: SupplierUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    regionId?: IntFieldUpdateOperationsInput | number
    parishes?: ParishUncheckedUpdateManyWithoutLocationNestedInput
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type ParishUpsertWithoutProductInput = {
    update: XOR<ParishUpdateWithoutProductInput, ParishUncheckedUpdateWithoutProductInput>
    create: XOR<ParishCreateWithoutProductInput, ParishUncheckedCreateWithoutProductInput>
    where?: ParishWhereInput
  }

  export type ParishUpdateToOneWithWhereWithoutProductInput = {
    where?: ParishWhereInput
    data: XOR<ParishUpdateWithoutProductInput, ParishUncheckedUpdateWithoutProductInput>
  }

  export type ParishUpdateWithoutProductInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutParishesNestedInput
    materials?: MaterialUpdateManyWithoutParishNestedInput
    Rate?: RateUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUncheckedUpdateManyWithoutParishNestedInput
    Rate?: RateUncheckedUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutParishNestedInput
  }

  export type MaterialUpsertWithoutProductInput = {
    update: XOR<MaterialUpdateWithoutProductInput, MaterialUncheckedUpdateWithoutProductInput>
    create: XOR<MaterialCreateWithoutProductInput, MaterialUncheckedCreateWithoutProductInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutProductInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutProductInput, MaterialUncheckedUpdateWithoutProductInput>
  }

  export type MaterialUpdateWithoutProductInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutMaterialsNestedInput
    units?: UnitUpdateOneRequiredWithoutMaterialsNestedInput
    rates?: RateUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type UnitUpsertWithoutProductInput = {
    update: XOR<UnitUpdateWithoutProductInput, UnitUncheckedUpdateWithoutProductInput>
    create: XOR<UnitCreateWithoutProductInput, UnitUncheckedCreateWithoutProductInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutProductInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutProductInput, UnitUncheckedUpdateWithoutProductInput>
  }

  export type UnitUpdateWithoutProductInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUpdateManyWithoutUnitsNestedInput
    Rate?: RateUpdateManyWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutUnitsNestedInput
    Rate?: RateUncheckedUpdateManyWithoutUnitsNestedInput
  }

  export type RateUpsertWithoutProductInput = {
    update: XOR<RateUpdateWithoutProductInput, RateUncheckedUpdateWithoutProductInput>
    create: XOR<RateCreateWithoutProductInput, RateUncheckedCreateWithoutProductInput>
    where?: RateWhereInput
  }

  export type RateUpdateToOneWithWhereWithoutProductInput = {
    where?: RateWhereInput
    data: XOR<RateUpdateWithoutProductInput, RateUncheckedUpdateWithoutProductInput>
  }

  export type RateUpdateWithoutProductInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    parish?: ParishUpdateOneRequiredWithoutRateNestedInput
    material?: MaterialUpdateOneRequiredWithoutRatesNestedInput
    units?: UnitUpdateOneRequiredWithoutRateNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RateUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type LocationCreateManyRegionInput = {
    id?: number
    locationName: string
  }

  export type LocationUpdateWithoutRegionInput = {
    locationName?: StringFieldUpdateOperationsInput | string
    parishes?: ParishUpdateManyWithoutLocationNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
    Product?: ProductUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
    parishes?: ParishUncheckedUpdateManyWithoutLocationNestedInput
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
    Product?: ProductUncheckedUpdateManyWithoutLocationNameNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutLocationNameNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationName?: StringFieldUpdateOperationsInput | string
  }

  export type ParishCreateManyLocationInput = {
    id?: number
    parishName: string
  }

  export type UserCreateManyLocationInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
  }

  export type ProductCreateManyLocationNameInput = {
    id?: number
    rateId: number
    supplierId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type SupplierCreateManyLocationNameInput = {
    id?: number
    supplierName: string
    parishId: number
  }

  export type ParishUpdateWithoutLocationInput = {
    parishName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUpdateManyWithoutParishNestedInput
    Rate?: RateUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUpdateManyWithoutParishNestedInput
    Product?: ProductUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutParishNestedInput
    Rate?: RateUncheckedUpdateManyWithoutParishNestedInput
    Supplier?: SupplierUncheckedUpdateManyWithoutParishNestedInput
    Product?: ProductUncheckedUpdateManyWithoutParishNestedInput
  }

  export type ParishUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    parishName?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutLocationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutLocationNameInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutLocationNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutLocationNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierUpdateWithoutLocationNameInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutSupplierNestedInput
    rates?: RateUpdateManyWithoutSupplierNestedInput
    Product?: ProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutLocationNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutSupplierNestedInput
    Product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutLocationNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateManyParishInput = {
    id?: number
    materialName: string
    unitsId: number
  }

  export type RateCreateManyParishInput = {
    id?: number
    rateValue: number
    materialId: number
    unitsId: number
    supplierId: number
  }

  export type SupplierCreateManyParishInput = {
    id?: number
    supplierName: string
    locationId: number
  }

  export type ProductCreateManyParishInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    materialId: number
    unitsId: number
  }

  export type MaterialUpdateWithoutParishInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    units?: UnitUpdateOneRequiredWithoutMaterialsNestedInput
    rates?: RateUpdateManyWithoutMaterialNestedInput
    Product?: ProductUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    unitsId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutMaterialNestedInput
    Product?: ProductUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type RateUpdateWithoutParishInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    material?: MaterialUpdateOneRequiredWithoutRatesNestedInput
    units?: UnitUpdateOneRequiredWithoutRateNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutRatesNestedInput
    Product?: ProductUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateManyWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierUpdateWithoutParishInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    locationName?: LocationUpdateOneRequiredWithoutSupplierNestedInput
    rates?: RateUpdateManyWithoutSupplierNestedInput
    Product?: ProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutSupplierNestedInput
    Product?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutParishInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutParishInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type RateCreateManyMaterialInput = {
    id?: number
    rateValue: number
    parishId: number
    unitsId: number
    supplierId: number
  }

  export type ProductCreateManyMaterialInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    unitsId: number
  }

  export type RateUpdateWithoutMaterialInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    parish?: ParishUpdateOneRequiredWithoutRateNestedInput
    units?: UnitUpdateOneRequiredWithoutRateNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutRatesNestedInput
    Product?: ProductUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutMaterialInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateManyUnitsInput = {
    id?: number
    materialName: string
    parishId: number
  }

  export type RateCreateManyUnitsInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    supplierId: number
  }

  export type ProductCreateManyUnitsInput = {
    id?: number
    rateId: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
  }

  export type MaterialUpdateWithoutUnitsInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    parish?: ParishUpdateOneRequiredWithoutMaterialsNestedInput
    rates?: RateUpdateManyWithoutMaterialNestedInput
    Product?: ProductUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
    rates?: RateUncheckedUpdateManyWithoutMaterialNestedInput
    Product?: ProductUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    parishId?: IntFieldUpdateOperationsInput | number
  }

  export type RateUpdateWithoutUnitsInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    parish?: ParishUpdateOneRequiredWithoutRateNestedInput
    material?: MaterialUpdateOneRequiredWithoutRatesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutRatesNestedInput
    Product?: ProductUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateManyWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutUnitsInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyRateDetailsInput = {
    id?: number
    supplierId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductUpdateWithoutRateDetailsInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductNestedInput
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRateDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutRateDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type RateCreateManySupplierInput = {
    id?: number
    rateValue: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type ProductCreateManySupplierInput = {
    id?: number
    rateId: number
    locationId: number
    parishId: number
    materialId: number
    unitsId: number
  }

  export type RateUpdateWithoutSupplierInput = {
    rateValue?: FloatFieldUpdateOperationsInput | number
    parish?: ParishUpdateOneRequiredWithoutRateNestedInput
    material?: MaterialUpdateOneRequiredWithoutRatesNestedInput
    units?: UnitUpdateOneRequiredWithoutRateNestedInput
    Product?: ProductUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
    Product?: ProductUncheckedUpdateManyWithoutRateDetailsNestedInput
  }

  export type RateUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateValue?: FloatFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutSupplierInput = {
    locationName?: LocationUpdateOneRequiredWithoutProductNestedInput
    parish?: ParishUpdateOneRequiredWithoutProductNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductNestedInput
    units?: UnitUpdateOneRequiredWithoutProductNestedInput
    rateDetails?: RateUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    rateId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    parishId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitsId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishCountOutputTypeDefaultArgs instead
     */
    export type ParishCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialCountOutputTypeDefaultArgs instead
     */
    export type MaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateCountOutputTypeDefaultArgs instead
     */
    export type RateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParishDefaultArgs instead
     */
    export type ParishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParishDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialDefaultArgs instead
     */
    export type MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateDefaultArgs instead
     */
    export type RateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}